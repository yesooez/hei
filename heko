local CONFIG = { DISCORD = 'https://discord.gg/89nFQcDETE', OWNER_KEY = 'ko1234F', UNIVERSAL_KEY = 'brutal', FILES = { BLACKLIST = 'brutal_emergency_blacklist.txt', USER_LOGS = 'brutal_emergency_user_logs.txt', ANNOUNCEMENT = 'brutal_emergency_announcement.txt', }, } local Players = game:GetService('Players') local TweenService = game:GetService('TweenService') local CoreGui = game:GetService('CoreGui') local Player = Players.LocalPlayer local UserId = tostring(Player.UserId) local Username = Player.Name print('[BRUTAL EMERGENCY] Player: ' .. Username) print('[BRUTAL EMERGENCY] UserID: ' .. UserId)
for
_, gui in ipairs(CoreGui:GetChildren())
do
  
  if
  gui.Name:match('BRUTAL')
  then
    gui:Destroy()
  end
  
end
local
function
  WriteFile(filename, content)
  if
  writefile
  then
    local success = pcall(
    function
      () writefile(filename, content)
    end
    ) print('[FILE] Write ' .. filename .. ': ' .. tostring(success)) return success
  end
  return false
end
local
function
  ReadFile(filename)
  if
  isfile and readfile and isfile(filename)
  then
    local success, result = pcall(
    function
      () return readfile(filename)
    end
    )
    if
    success
    then
      print('[FILE] Read ' .. filename .. ': SUCCESS') return result
    end
    
  end
  print('[FILE] Read ' .. filename .. ': FILE NOT FOUND') return nil
end
local
function
  AppendFile(filename, content)
  if
  appendfile
  then
    local success = pcall(
    function
      () appendfile(filename, content)
    end
    ) print('[FILE] Append ' .. filename .. ': ' .. tostring(success)) return success
  end
  return false
end
local
function
  LoadUserLogs() local content = ReadFile(CONFIG.FILES.USER_LOGS) local logs = {}
  if
  content
  then
    
    for
    line in string.gmatch(content, '([^\n]+)')
    do
      local uid = string.match(line, 'UserID:%s*(%d+)')
      if
      uid
      then
        logs[uid] = line
      end
      
    end
    
  end
  local count = 0
  for
  _ in pairs(logs)
  do
    count = count + 1
  end
  print('[LOGS] Loaded ' .. count .. ' unique users') return logs
end
local
function
  IsUserLogged(uid) local logs = LoadUserLogs() return logs[uid] ~= nil
end
local
function
  LogUser(uid, username, key) print( '═══════════════════════════════════════════════════════════════' ) print(' LOGGING USER NOW') print( '═══════════════════════════════════════════════════════════════' ) print('Username: ' .. username) print('UserID: ' .. uid) print('Key: ' .. key)
  if
  IsUserLogged(uid)
  then
    print('RESULT: User already logged - SKIPPING') print( '═══════════════════════════════════════════════════════════════' ) return false
  end
  local timestamp = os.date('%Y-%m-%d %H:%M:%S') local entry = string.format( '%s | User: %s | UserID: %s | Key: %s\n', timestamp, username, uid, key ) print('Creating entry: ' .. entry) local success = AppendFile(CONFIG.FILES.USER_LOGS, entry)
  if
  success
  then
    print('✓✓✓ USER LOGGED SUCCESSFULLY ✓✓✓')
  else
    print('✗✗✗ LOGGING FAILED ✗✗✗')
  end
  print( '═══════════════════════════════════════════════════════════════' ) return success
end
local
function
  GetAllLogs() local content = ReadFile(CONFIG.FILES.USER_LOGS) return content
end
local
function
  GetLogCount() local logs = LoadUserLogs() local count = 0
  for
  _ in pairs(logs)
  do
    count = count + 1
  end
  return count
end
local
function
  ClearAllLogs() return WriteFile(CONFIG.FILES.USER_LOGS, '')
end
local
function
  LoadBlacklist() local content = ReadFile(CONFIG.FILES.BLACKLIST) local list = {}
  if
  content
  then
    
    for
    id in string.gmatch(content, '([^\n]+)')
    do
      id = id:gsub('%s+', '')
      if
      id ~= ''
      then
        table.insert(list, id)
      end
      
    end
    
  end
  return list
end
local
function
  IsBlacklisted(uid) local list = LoadBlacklist()
  for
  _, id in ipairs(list)
  do
    
    if
    tostring(id) == tostring(uid)
    then
      return true
    end
    
  end
  return false
end
local
function
  AddBlacklist(uid) local list = LoadBlacklist() table.insert(list, uid) return WriteFile(CONFIG.FILES.BLACKLIST, table.concat(list, '\n'))
end
local
function
  RemoveBlacklist(uid) local list = LoadBlacklist() local newList = {}
  for
  _, id in ipairs(list)
  do
    
    if
    tostring(id) ~= tostring(uid)
    then
      table.insert(newList, id)
    end
    
  end
  return WriteFile(CONFIG.FILES.BLACKLIST, table.concat(newList, '\n'))
end
local
function
  GetAnnouncement() return ReadFile(CONFIG.FILES.ANNOUNCEMENT) or ''
end
local
function
  SetAnnouncement(text) return WriteFile(CONFIG.FILES.ANNOUNCEMENT, text)
end
local
function
  VerifyKey(key) key = tostring(key):gsub('%s+', '')
  if
  key == CONFIG.OWNER_KEY
  then
    print('[KEY] Owner key verified') return true, true
  end
  
  if
  key == CONFIG.UNIVERSAL_KEY
  then
    print('[KEY] Universal key verified') return true, false
  end
  return false, false
end
local
function
  CreateCorner(parent, radius) local corner = Instance.new('UICorner', parent) corner.CornerRadius = UDim.new(0, radius or 8) return corner
end
local
function
  ShowLoader(callback) local loader = Instance.new('ScreenGui') loader.Name = 'BRUTAL_LOADER_EMERGENCY' loader.ResetOnSpawn = false loader.Parent = CoreGui local bg = Instance.new('Frame', loader) bg.Size = UDim2.new(0, 450, 0, 360) bg.Position = UDim2.new(0.5, -225, 0.5, -180) bg.BackgroundColor3 = Color3.fromRGB(15, 15, 20) bg.BorderSizePixel = 0 CreateCorner(bg, 24) local grad = Instance.new('UIGradient', bg) grad.Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.fromRGB(120, 20, 20)), ColorSequenceKeypoint.new(0.5, Color3.fromRGB(15, 15, 20)), ColorSequenceKeypoint.new(1, Color3.fromRGB(15, 15, 20)), }) grad.Rotation = 45 local title = Instance.new('TextLabel', bg) title.Size = UDim2.new(1, 0, 0, 80) title.Position = UDim2.new(0, 0, 0.3, 0) title.BackgroundTransparency = 1 title.Text = 'BRUTAL' title.Font = Enum.Font.GothamBlack title.TextSize = 64 title.TextColor3 = Color3.fromRGB(255, 255, 255) local loadingText = Instance.new('TextLabel', bg) loadingText.Size = UDim2.new(1, 0, 0, 40) loadingText.Position = UDim2.new(0, 0, 0.6, 0) loadingText.BackgroundTransparency = 1 loadingText.Text = 'Loading Brutal' loadingText.Font = Enum.Font.Gotham loadingText.TextSize = 20 loadingText.TextColor3 = Color3.fromRGB(200, 200, 200) local running = true local dots = 0 task.spawn(
  function
    ()
    while
    running and loadingText and loadingText.Parent
    do
      dots = (dots % 3) + 1
      if
      loadingText
      then
        loadingText.Text = 'Loading Brutal' .. string.rep('.', dots)
      end
      task.wait(0.5)
    end
    
  end
  ) task.wait(2) running = false
  if
  loader and loader.Parent
  then
    TweenService :Create(bg, TweenInfo.new(0.5), { BackgroundTransparency = 1 }) :Play() TweenService:Create(title, TweenInfo.new(0.5), { TextTransparency = 1 }) :Play() local tween = TweenService:Create( loadingText, TweenInfo.new(0.5), { TextTransparency = 1 } ) tween:Play() tween.Completed:Wait() loader:Destroy()
  end
  
  if
  callback
  then
    callback()
  end
  
end
local
function
  ShowBanScreen() local ban = Instance.new('ScreenGui') ban.Name = 'BRUTAL_BAN_EMERGENCY' ban.ResetOnSpawn = false ban.Parent = CoreGui local bg = Instance.new('Frame', ban) bg.Size = UDim2.new(0, 500, 0, 300) bg.Position = UDim2.new(0.5, -250, 0.5, -150) bg.BackgroundColor3 = Color3.fromRGB(18, 18, 22) bg.BorderSizePixel = 0 CreateCorner(bg, 20) local title = Instance.new('TextLabel', bg) title.Size = UDim2.new(1, -40, 0, 80) title.Position = UDim2.new(0, 20, 0, 60) title.BackgroundTransparency = 1 title.Text = 'YOU ARE BANNED FROM BRUTAL' title.TextColor3 = Color3.fromRGB(255, 60, 60) title.TextSize = 24 title.Font = Enum.Font.GothamBlack title.TextWrapped = true local info = Instance.new('TextLabel', bg) info.Size = UDim2.new(1, -40, 0, 60) info.Position = UDim2.new(0, 20, 0, 150) info.BackgroundTransparency = 1 info.Text = 'Your UserID has been blacklisted.\nContact support
  for
  more information.' info.TextColor3 = Color3.fromRGB(200, 200, 200) info.TextSize = 14 info.Font = Enum.Font.Gotham info.TextWrapped = true local discord = Instance.new('TextLabel', bg) discord.Size = UDim2.new(1, -40, 0, 30) discord.Position = UDim2.new(0, 20, 0, 230) discord.BackgroundTransparency = 1 discord.Text = CONFIG.DISCORD discord.TextColor3 = Color3.fromRGB(120, 20, 20) discord.TextSize = 16 discord.Font = Enum.Font.GothamBold task.wait(3) Player:Kick('BANNED FROM BRUTAL | Contact: ' .. CONFIG.DISCORD)
end
local
function
  CreateKeyGUI(onSuccess) print('[GUI] Creating key GUI...') local gui = Instance.new('ScreenGui') gui.Name = 'BRUTAL_KEY_GUI_EMERGENCY' gui.ResetOnSpawn = false gui.Parent = CoreGui local frame = Instance.new('Frame', gui) frame.Size = UDim2.new(0, 480, 0, 320) frame.Position = UDim2.new(0.5, -240, 0.5, -160) frame.BackgroundColor3 = Color3.fromRGB(18, 18, 24) frame.BorderSizePixel = 0 CreateCorner(frame, 24) local grad = Instance.new('UIGradient', frame) grad.Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.fromRGB(120, 20, 20)), ColorSequenceKeypoint.new(0.4, Color3.fromRGB(18, 18, 24)), ColorSequenceKeypoint.new(1, Color3.fromRGB(18, 18, 24)), }) grad.Rotation = 30 local header = Instance.new('TextLabel', frame) header.Size = UDim2.new(1, 0, 0, 60) header.BackgroundTransparency = 1 header.Text = 'BRUTAL' header.Font = Enum.Font.GothamBlack header.TextSize = 32 header.TextColor3 = Color3.fromRGB(255, 255, 255) local info = Instance.new('TextLabel', frame) info.Size = UDim2.new(1, -40, 0, 20) info.Position = UDim2.new(0, 20, 0, 70) info.BackgroundTransparency = 1 info.Text = 'Universal Key: brutal' info.TextColor3 = Color3.fromRGB(255, 200, 100) info.TextSize = 14 info.Font = Enum.Font.GothamBold info.TextXAlignment = Enum.TextXAlignment.Left local discordFrame = Instance.new('Frame', frame) discordFrame.Size = UDim2.new(1, -40, 0, 30) discordFrame.Position = UDim2.new(0, 20, 0, 95) discordFrame.BackgroundTransparency = 1 local icon = Instance.new('ImageLabel', discordFrame) icon.BackgroundTransparency = 1 icon.Size = UDim2.new(0, 20, 0, 20) icon.Position = UDim2.new(0, 0, 0, 5) icon.Image = 'rbxassetid://6031075938' icon.ImageColor3 = Color3.fromRGB(120, 20, 20) local link = Instance.new('TextLabel', discordFrame) link.BackgroundTransparency = 1 link.Size = UDim2.new(0.6, 0, 1, 0) link.Position = UDim2.new(0, 25, 0, 0) link.Text = CONFIG.DISCORD link.TextColor3 = Color3.fromRGB(120, 20, 20) link.Font = Enum.Font.GothamSemibold link.TextSize = 14 link.TextXAlignment = Enum.TextXAlignment.Left local copy = Instance.new('TextButton', discordFrame) copy.Size = UDim2.new(0, 50, 1, 0) copy.Position = UDim2.new(0.65, 0, 0, 0) copy.BackgroundColor3 = Color3.fromRGB(120, 20, 20) copy.Text = 'Copy' copy.Font = Enum.Font.GothamBold copy.TextSize = 13 copy.TextColor3 = Color3.fromRGB(255, 255, 255) CreateCorner(copy, 8) copy.MouseButton1Click:Connect(
  function
    ()
    if
    setclipboard
    then
      setclipboard(CONFIG.DISCORD) copy.Text = 'Copied' task.wait(1) copy.Text = 'Copy'
    end
    
  end
  ) local keyBox = Instance.new('TextBox', frame) keyBox.Size = UDim2.new(1, -40, 0, 45) keyBox.Position = UDim2.new(0, 20, 0, 145) keyBox.BackgroundColor3 = Color3.fromRGB(30, 30, 38) keyBox.PlaceholderText = 'Enter Key' keyBox.Text = '' keyBox.TextColor3 = Color3.fromRGB(255, 255, 255) keyBox.Font = Enum.Font.GothamBold keyBox.TextSize = 18 CreateCorner(keyBox, 12) local verify = Instance.new('TextButton', frame) verify.Size = UDim2.new(1, -40, 0, 45) verify.Position = UDim2.new(0, 20, 0, 205) verify.BackgroundColor3 = Color3.fromRGB(120, 20, 20) verify.Text = 'VERIFY KEY' verify.Font = Enum.Font.GothamBlack verify.TextSize = 18 verify.TextColor3 = Color3.fromRGB(255, 255, 255) CreateCorner(verify, 12) local status = Instance.new('TextLabel', frame) status.Size = UDim2.new(1, -40, 0, 20) status.Position = UDim2.new(0, 20, 0, 258) status.BackgroundTransparency = 1 status.Text = '' status.Font = Enum.Font.Gotham status.TextSize = 13 status.TextColor3 = Color3.fromRGB(255, 100, 100) local announcement = GetAnnouncement()
  if
  announcement ~= ''
  then
    local annFrame = Instance.new('Frame', frame) annFrame.Size = UDim2.new(1, -40, 0, 50) annFrame.Position = UDim2.new(0, 20, 0, 280) annFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 38) CreateCorner(annFrame, 10) local annLabel = Instance.new('TextLabel', annFrame) annLabel.Size = UDim2.new(1, -20, 1, -10) annLabel.Position = UDim2.new(0, 10, 0, 5) annLabel.BackgroundTransparency = 1 annLabel.Text = announcement annLabel.TextColor3 = Color3.fromRGB(255, 200, 100) annLabel.TextSize = 11 annLabel.Font = Enum.Font.Gotham annLabel.TextWrapped = true annLabel.TextYAlignment = Enum.TextYAlignment.Top frame.Size = UDim2.new(0, 480, 0, 350) frame.Position = UDim2.new(0.5, -240, 0.5, -175)
  end
  verify.MouseButton1Click:Connect(
  function
    () local key = keyBox.Text:gsub('%s+', '') print('[VERIFY] Button clicked') print('[VERIFY] Key entered: ' .. key)
    if
    key == ''
    then
      status.TextColor3 = Color3.fromRGB(255, 100, 100) status.Text = 'Please enter a key' return
    end
    local valid, isOwner = VerifyKey(key) print( '[VERIFY] Valid: ' .. tostring(valid) .. ' | Owner: ' .. tostring(isOwner) )
    if
    not valid
    then
      status.TextColor3 = Color3.fromRGB(255, 100, 100) status.Text = 'WRONG KEY - Invalid' keyBox.Text = '' return
    end
    
    if
    IsBlacklisted(UserId)
    then
      print('[VERIFY] User is blacklisted') gui:Destroy() ShowBanScreen() return
    end
    print( '[VERIFY] ═══════════════════════════════════════════════════' ) print('[VERIFY] KEY VERIFIED - LOGGING USER NOW') print( '[VERIFY] ═══════════════════════════════════════════════════' ) LogUser(UserId, Username, key) status.TextColor3 = Color3.fromRGB(100, 255, 100) status.Text = 'Verified! Loading...' task.wait(1) gui:Destroy()
    if
    onSuccess
    then
      onSuccess(isOwner)
    end
    
  end
  )
end
local
function
  CreateOwnerPanel() print('[OWNER] Creating owner panel...') local owner = Instance.new('ScreenGui') owner.Name = 'BRUTAL_OWNER_PANEL_EMERGENCY' owner.ResetOnSpawn = false owner.Parent = CoreGui local main = Instance.new('Frame', owner) main.Size = UDim2.new(0, 950, 0, 650) main.Position = UDim2.new(0.5, -475, 0.5, -325) main.BackgroundColor3 = Color3.fromRGB(18, 18, 22) main.BorderSizePixel = 0 CreateCorner(main, 14) local bar = Instance.new('Frame', main) bar.Size = UDim2.new(1, 0, 0, 60) bar.BackgroundColor3 = Color3.fromRGB(120, 20, 20) CreateCorner(bar, 14) local label = Instance.new('TextLabel', bar) label.Size = UDim2.new(1, -300, 1, 0) label.Position = UDim2.new(0, 20, 0, 0) label.BackgroundTransparency = 1 label.Text = 'BRUTAL OWNER PANEL V2.0' label.TextColor3 = Color3.fromRGB(255, 255, 255) label.TextSize = 22 label.Font = Enum.Font.GothamBlack label.TextXAlignment = Enum.TextXAlignment.Left local userLbl = Instance.new('TextLabel', bar) userLbl.Size = UDim2.new(0, 200, 0, 25) userLbl.Position = UDim2.new(1, -260, 0, 10) userLbl.BackgroundTransparency = 1 userLbl.Text = Username userLbl.TextColor3 = Color3.fromRGB(255, 255, 255) userLbl.TextSize = 12 userLbl.Font = Enum.Font.GothamBold userLbl.TextXAlignment = Enum.TextXAlignment.Right local idLbl = Instance.new('TextLabel', bar) idLbl.Size = UDim2.new(0, 200, 0, 20) idLbl.Position = UDim2.new(1, -260, 0, 32) idLbl.BackgroundTransparency = 1 idLbl.Text = 'ID: ' .. UserId idLbl.TextColor3 = Color3.fromRGB(180, 180, 180) idLbl.TextSize = 10 idLbl.Font = Enum.Font.Gotham idLbl.TextXAlignment = Enum.TextXAlignment.Right local close = Instance.new('TextButton', bar) close.Size = UDim2.new(0, 40, 0, 40) close.Position = UDim2.new(1, -50, 0, 10) close.BackgroundColor3 = Color3.fromRGB(25, 25, 30) close.Text = 'X' close.TextSize = 20 close.Font = Enum.Font.GothamBold close.TextColor3 = Color3.fromRGB(255, 255, 255) CreateCorner(close, 8) close.MouseButton1Click:Connect(
  function
    () owner:Destroy()
  end
  ) local sidebar = Instance.new('Frame', main) sidebar.Size = UDim2.new(0, 200, 1, -60) sidebar.Position = UDim2.new(0, 0, 0, 60) sidebar.BackgroundColor3 = Color3.fromRGB(22, 22, 28) sidebar.BorderSizePixel = 0 local tabNames = { 'User Logs', 'Blacklist', 'Announcements', 'Execute Script' } local tabBtns = {} local contents = {}
  for
  i, name in ipairs(tabNames)
  do
    local btn = Instance.new('TextButton', sidebar) btn.Size = UDim2.new(1, -16, 0, 45) btn.Position = UDim2.new(0, 8, 0, (i - 1) * 52 + 10) btn.BackgroundColor3 = i == 1 and Color3.fromRGB(120, 20, 20) or Color3.fromRGB(28, 28, 35) btn.Text = name btn.TextSize = 14 btn.Font = Enum.Font.GothamBold btn.TextColor3 = Color3.fromRGB(255, 255, 255) CreateCorner(btn, 8) tabBtns[i] = btn local content = Instance.new('ScrollingFrame', main) content.Size = UDim2.new(1, -220, 1, -80) content.Position = UDim2.new(0, 210, 0, 70) content.BackgroundTransparency = 1 content.BorderSizePixel = 0 content.ScrollBarThickness = 4 content.Visible = i == 1 content.CanvasSize = UDim2.new(0, 0, 0, 0) contents[i] = content btn.MouseButton1Click:Connect(
    function
      ()
      for
      j, b in ipairs(tabBtns)
      do
        b.BackgroundColor3 = j == i and Color3.fromRGB(120, 20, 20) or Color3.fromRGB(28, 28, 35) contents[j].Visible = j == i
      end
      
    end
    )
  end
  local logTab = contents[1] local logHeader = Instance.new('TextLabel', logTab) logHeader.Size = UDim2.new(1, -20, 0, 40) logHeader.Position = UDim2.new(0, 10, 0, 10) logHeader.BackgroundColor3 = Color3.fromRGB(25, 25, 30) logHeader.Text = 'User Execution Logs (Unique Users)' logHeader.TextColor3 = Color3.fromRGB(255, 255, 255) logHeader.TextSize = 16 logHeader.Font = Enum.Font.GothamBlack CreateCorner(logHeader, 8) local logCount = Instance.new('TextLabel', logTab) logCount.Size = UDim2.new(1, -20, 0, 30) logCount.Position = UDim2.new(0, 10, 0, 60) logCount.BackgroundColor3 = Color3.fromRGB(30, 30, 38) logCount.Text = 'Total Unique Users: ' .. GetLogCount() logCount.TextColor3 = Color3.fromRGB(255, 200, 100) logCount.TextSize = 14 logCount.Font = Enum.Font.GothamBold CreateCorner(logCount, 8) local logDisplay = Instance.new('TextBox', logTab) logDisplay.Size = UDim2.new(1, -20, 0, 370) logDisplay.Position = UDim2.new(0, 10, 0, 100) logDisplay.BackgroundColor3 = Color3.fromRGB(25, 25, 30) logDisplay.TextColor3 = Color3.fromRGB(255, 255, 255) logDisplay.TextSize = 11 logDisplay.Font = Enum.Font.Code logDisplay.TextXAlignment = Enum.TextXAlignment.Left logDisplay.TextYAlignment = Enum.TextYAlignment.Top logDisplay.ClearTextOnFocus = false logDisplay.MultiLine = true logDisplay.TextEditable = false CreateCorner(logDisplay, 8) local logs = GetAllLogs() logDisplay.Text = logs or 'No users logged yet.\n\nWhen users enter key "brutal" and click VERIFY,\nthey will be logged here.\n\nEach UserID is only logged once.' local refreshLog = Instance.new('TextButton', logTab) refreshLog.Size = UDim2.new(0, 160, 0, 40) refreshLog.Position = UDim2.new(0, 10, 0, 480) refreshLog.BackgroundColor3 = Color3.fromRGB(120, 20, 20) refreshLog.Text = 'Refresh Logs' refreshLog.TextSize = 14 refreshLog.Font = Enum.Font.GothamBold refreshLog.TextColor3 = Color3.fromRGB(255, 255, 255) CreateCorner(refreshLog, 8) refreshLog.MouseButton1Click:Connect(
  function
    () local newLogs = GetAllLogs() logDisplay.Text = newLogs or 'No users logged yet.' logCount.Text = 'Total Unique Users: ' .. GetLogCount() refreshLog.Text = 'Refreshed!' task.wait(1) refreshLog.Text = 'Refresh Logs'
  end
  ) local clearLog = Instance.new('TextButton', logTab) clearLog.Size = UDim2.new(0, 160, 0, 40) clearLog.Position = UDim2.new(0, 180, 0, 480) clearLog.BackgroundColor3 = Color3.fromRGB(120, 20, 20) clearLog.Text = 'Clear All Logs' clearLog.TextSize = 14 clearLog.Font = Enum.Font.GothamBold clearLog.TextColor3 = Color3.fromRGB(255, 255, 255) CreateCorner(clearLog, 8) clearLog.MouseButton1Click:Connect(
  function
    () ClearAllLogs() logDisplay.Text = 'No users logged yet.' logCount.Text = 'Total Unique Users: 0' clearLog.Text = 'Cleared!' task.wait(1) clearLog.Text = 'Clear All Logs'
  end
  ) logTab.CanvasSize = UDim2.new(0, 0, 0, 540) local blTab = contents[2] local blHeader = Instance.new('TextLabel', blTab) blHeader.Size = UDim2.new(1, -20, 0, 40) blHeader.Position = UDim2.new(0, 10, 0, 10) blHeader.BackgroundColor3 = Color3.fromRGB(25, 25, 30) blHeader.Text = 'Blacklist Manager' blHeader.TextColor3 = Color3.fromRGB(255, 255, 255) blHeader.TextSize = 16 blHeader.Font = Enum.Font.GothamBlack CreateCorner(blHeader, 8) local blListFrame = Instance.new('Frame', blTab) blListFrame.Size = UDim2.new(1, -20, 0, 340) blListFrame.Position = UDim2.new(0, 10, 0, 60) blListFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 30) CreateCorner(blListFrame, 8) local blListScroll = Instance.new('ScrollingFrame', blListFrame) blListScroll.Size = UDim2.new(1, -10, 1, -10) blListScroll.Position = UDim2.new(0, 5, 0, 5) blListScroll.BackgroundTransparency = 1 blListScroll.BorderSizePixel = 0 blListScroll.ScrollBarThickness = 4 local blListLayout = Instance.new('UIListLayout', blListScroll) blListLayout.Padding = UDim.new(0, 6) blListLayout.SortOrder = Enum.SortOrder.LayoutOrder local
  function
    refreshBlacklist()
    for
    _, child in ipairs(blListScroll:GetChildren())
    do
      
      if
      child:IsA('Frame')
      then
        child:Destroy()
      end
      
    end
    local blacklist = LoadBlacklist()
    if
    #blacklist == 0
    then
      local emptyLabel = Instance.new('TextLabel', blListScroll) emptyLabel.Size = UDim2.new(1, -10, 0, 50) emptyLabel.BackgroundTransparency = 1 emptyLabel.Text = 'No blacklisted users' emptyLabel.TextColor3 = Color3.fromRGB(150, 150, 150) emptyLabel.TextSize = 14 emptyLabel.Font = Enum.Font.Gotham
    else
      
      for
      _, id in ipairs(blacklist)
      do
        local blFrame = Instance.new('Frame', blListScroll) blFrame.Size = UDim2.new(1, -10, 0, 42) blFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 38) CreateCorner(blFrame, 6) local idText = Instance.new('TextLabel', blFrame) idText.Size = UDim2.new(0.6, 0, 1, 0) idText.Position = UDim2.new(0, 12, 0, 0) idText.BackgroundTransparency = 1 idText.Text = 'UserID: ' .. id idText.TextColor3 = Color3.fromRGB(255, 100, 100) idText.TextSize = 13 idText.Font = Enum.Font.Code idText.TextXAlignment = Enum.TextXAlignment.Left local copyBtn = Instance.new('TextButton', blFrame) copyBtn.Size = UDim2.new(0, 65, 0, 30) copyBtn.Position = UDim2.new(1, -155, 0, 6) copyBtn.BackgroundColor3 = Color3.fromRGB(50, 120, 50) copyBtn.Text = 'Copy ID' copyBtn.TextSize = 11 copyBtn.Font = Enum.Font.GothamBold copyBtn.TextColor3 = Color3.fromRGB(255, 255, 255) CreateCorner(copyBtn, 5) copyBtn.MouseButton1Click:Connect(
        function
          ()
          if
          setclipboard
          then
            setclipboard(id) copyBtn.Text = 'Copied!' task.wait(1) copyBtn.Text = 'Copy ID'
          end
          
        end
        ) local removeBtn = Instance.new('TextButton', blFrame) removeBtn.Size = UDim2.new(0, 75, 0, 30) removeBtn.Position = UDim2.new(1, -85, 0, 6) removeBtn.BackgroundColor3 = Color3.fromRGB(60, 140, 60) removeBtn.Text = 'Remove' removeBtn.TextSize = 11 removeBtn.Font = Enum.Font.GothamBold removeBtn.TextColor3 = Color3.fromRGB(255, 255, 255) CreateCorner(removeBtn, 5) removeBtn.MouseButton1Click:Connect(
        function
          () RemoveBlacklist(id) refreshBlacklist()
        end
        )
      end
      
    end
    blListScroll.CanvasSize = UDim2.new(0, 0, 0, blListLayout.AbsoluteContentSize.Y + 10)
  end
  refreshBlacklist() local blAddBox = Instance.new('TextBox', blTab) blAddBox.Size = UDim2.new(1, -190, 0, 40) blAddBox.Position = UDim2.new(0, 180, 0, 410) blAddBox.BackgroundColor3 = Color3.fromRGB(30, 30, 38) blAddBox.PlaceholderText = 'Enter UserID to blacklist' blAddBox.Text = '' blAddBox.TextColor3 = Color3.fromRGB(255, 255, 255) blAddBox.TextSize = 13 blAddBox.Font = Enum.Font.Code CreateCorner(blAddBox, 8) local blAddBtn = Instance.new('TextButton', blTab) blAddBtn.Size = UDim2.new(0, 160, 0, 40) blAddBtn.Position = UDim2.new(0, 10, 0, 410) blAddBtn.BackgroundColor3 = Color3.fromRGB(120, 20, 20) blAddBtn.Text = 'Add to Blacklist' blAddBtn.TextSize = 14 blAddBtn.Font = Enum.Font.GothamBold blAddBtn.TextColor3 = Color3.fromRGB(255, 255, 255) CreateCorner(blAddBtn, 8) blAddBtn.MouseButton1Click:Connect(
  function
    () local id = blAddBox.Text:gsub('%s+', '')
    if
    id ~= ''
    then
      AddBlacklist(id) blAddBox.Text = '' refreshBlacklist() blAddBtn.Text = 'Added!' task.wait(1) blAddBtn.Text = 'Add to Blacklist'
    end
    
  end
  ) blTab.CanvasSize = UDim2.new(0, 0, 0, 470) local annTab = contents[3] local annHeader = Instance.new('TextLabel', annTab) annHeader.Size = UDim2.new(1, -20, 0, 40) annHeader.Position = UDim2.new(0, 10, 0, 10) annHeader.BackgroundColor3 = Color3.fromRGB(25, 25, 30) annHeader.Text = 'Global Announcement' annHeader.TextColor3 = Color3.fromRGB(255, 255, 255) annHeader.TextSize = 16 annHeader.Font = Enum.Font.GothamBlack CreateCorner(annHeader, 8) local annInfo = Instance.new('TextLabel', annTab) annInfo.Size = UDim2.new(1, -20, 0, 60) annInfo.Position = UDim2.new(0, 10, 0, 60) annInfo.BackgroundColor3 = Color3.fromRGB(25, 25, 30) annInfo.Text = 'This message will be shown to all users when they execute the script.\nUse this to notify about updates or important information.' annInfo.TextColor3 = Color3.fromRGB(200, 200, 200) annInfo.TextSize = 12 annInfo.Font = Enum.Font.Gotham annInfo.TextWrapped = true CreateCorner(annInfo, 8) local annBox = Instance.new('TextBox', annTab) annBox.Size = UDim2.new(1, -20, 0, 200) annBox.Position = UDim2.new(0, 10, 0, 130) annBox.BackgroundColor3 = Color3.fromRGB(25, 25, 30) annBox.TextColor3 = Color3.fromRGB(255, 255, 255) annBox.TextSize = 13 annBox.Font = Enum.Font.Gotham annBox.TextXAlignment = Enum.TextXAlignment.Left annBox.TextYAlignment = Enum.TextYAlignment.Top annBox.ClearTextOnFocus = false annBox.MultiLine = true annBox.PlaceholderText = 'Enter announcement message...' annBox.Text = GetAnnouncement() CreateCorner(annBox, 8) local saveAnn = Instance.new('TextButton', annTab) saveAnn.Size = UDim2.new(0, 180, 0, 45) saveAnn.Position = UDim2.new(0, 10, 0, 340) saveAnn.BackgroundColor3 = Color3.fromRGB(120, 20, 20) saveAnn.Text = 'Save Announcement' saveAnn.TextSize = 14 saveAnn.Font = Enum.Font.GothamBold saveAnn.TextColor3 = Color3.fromRGB(255, 255, 255) CreateCorner(saveAnn, 8) saveAnn.MouseButton1Click:Connect(
  function
    () SetAnnouncement(annBox.Text) saveAnn.Text = 'Saved!' task.wait(1) saveAnn.Text = 'Save Announcement'
  end
  ) local clearAnn = Instance.new('TextButton', annTab) clearAnn.Size = UDim2.new(0, 180, 0, 45) clearAnn.Position = UDim2.new(0, 200, 0, 340) clearAnn.BackgroundColor3 = Color3.fromRGB(120, 20, 20) clearAnn.Text = 'Clear Announcement' clearAnn.TextSize = 14 clearAnn.Font = Enum.Font.GothamBold clearAnn.TextColor3 = Color3.fromRGB(255, 255, 255) CreateCorner(clearAnn, 8) clearAnn.MouseButton1Click:Connect(
  function
    () annBox.Text = '' SetAnnouncement('') clearAnn.Text = 'Cleared!' task.wait(1) clearAnn.Text = 'Clear Announcement'
  end
  ) annTab.CanvasSize = UDim2.new(0, 0, 0, 400) local execTab = contents[4] local execHeader = Instance.new('TextLabel', execTab) execHeader.Size = UDim2.new(1, -20, 0, 40) execHeader.Position = UDim2.new(0, 10, 0, 10) execHeader.BackgroundColor3 = Color3.fromRGB(25, 25, 30) execHeader.Text = 'Execute Main Script' execHeader.TextColor3 = Color3.fromRGB(255, 255, 255) execHeader.TextSize = 16 execHeader.Font = Enum.Font.GothamBlack CreateCorner(execHeader, 8) local execInfo = Instance.new('TextLabel', execTab) execInfo.Size = UDim2.new(1, -20, 0, 50) execInfo.Position = UDim2.new(0, 10, 0, 60) execInfo.BackgroundColor3 = Color3.fromRGB(25, 25, 30) execInfo.Text = 'This will close the owner panel and execute the main script.' execInfo.TextColor3 = Color3.fromRGB(200, 200, 200) execInfo.TextSize = 12 execInfo.Font = Enum.Font.Gotham execInfo.TextWrapped = true CreateCorner(execInfo, 8) local execBtn = Instance.new('TextButton', execTab) execBtn.Size = UDim2.new(1, -20, 0, 75) execBtn.Position = UDim2.new(0, 10, 0, 120) execBtn.BackgroundColor3 = Color3.fromRGB(120, 20, 20) execBtn.Text = 'EXECUTE SCRIPT' execBtn.TextSize = 22 execBtn.Font = Enum.Font.GothamBlack execBtn.TextColor3 = Color3.fromRGB(255, 255, 255) CreateCorner(execBtn, 12) execBtn.MouseButton1Click:Connect(
  function
    () execBtn.Text = 'EXECUTING...' task.wait(0.5) owner:Destroy() ShowLoader(LoadUserScript)
  end
  ) execTab.CanvasSize = UDim2.new(0, 0, 0, 220) print('[OWNER] Owner panel created')
end

function
  LoadUserScript() print('[SCRIPT] Executing main script...') local repo = 'https://raw.githubusercontent.com/deividcomsono/Obsidian/main/' local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))() local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))() local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))() local Options = Library.Options local Window = Library:CreateWindow({ Title = 'Faisal', Center = true, AutoShow = true, TabPadding = 8, MenuFadeTime = 0.2, }) local Tabs = { Combat = Window:AddTab('Combat'), Player = Window:AddTab('Player'), Visuals = Window:AddTab('Visuals'), ['UI Settings'] = Window:AddTab('UI Settings', 'settings'), } local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu') MenuGroup:AddToggle('KeybindMenuOpen', { Default = Library.KeybindFrame.Visible, Text = 'Open Keybind Menu', Callback =
  function
    (value) Library.KeybindFrame.Visible = value
  end
  , }) MenuGroup:AddToggle('ShowCustomCursor', { Text = 'Custom Cursor', Default = true, Callback =
  function
    (Value) Library.ShowCustomCursor = Value
  end
  , }) MenuGroup:AddDropdown('NotificationSide', { Values = { 'Left', 'Right' }, Default = 'Right', Text = 'Notification Side', Callback =
  function
    (Value) Library:SetNotifySide(Value)
  end
  , }) MenuGroup:AddDropdown('DPIDropdown', { Values = { '50%', '75%', '100%', '125%', '150%', '175%', '200%' }, Default = '100%', Text = 'DPI Scale', Callback =
  function
    (Value) Value = Value:gsub('%%', '') local DPI = tonumber(Value) Library:SetDPIScale(DPI)
  end
  , }) MenuGroup:AddDivider() MenuGroup:AddLabel('Menu bind'):AddKeyPicker( 'MenuKeybind', { Default = 'Insert', NoUI = true, Text = 'Menu keybind' } ) MenuGroup:AddButton('Unload',
  function
    () Library:Unload()
  end
  ) Library.ToggleKeybind = Options.MenuKeybind ThemeManager:SetLibrary(Library) SaveManager:SetLibrary(Library) SaveManager:IgnoreThemeSettings() SaveManager:SetIgnoreIndexes({ 'MenuKeybind' }) ThemeManager:SetFolder('MyScriptHub') SaveManager:SetFolder('MyScriptHub/specific-game') SaveManager:SetSubFolder('specific-place') SaveManager:BuildConfigSection(Tabs['UI Settings']) ThemeManager:ApplyToTab(Tabs['UI Settings']) SaveManager:LoadAutoloadConfig() local Players = game:GetService('Players') local RunService = game:GetService('RunService') local Workspace = game:GetService('Workspace') local Camera = Workspace.CurrentCamera local LocalPlayer = Players.LocalPlayer local ESPEnabled = false local RainbowESP = false local ShowDisplayName = false local ShowUsername = false local ShowDistanceESP = false local ShowBoxESP = false local ESPObjects = {} local
  function
    getRainbowColor() return Color3.fromHSV(tick() % 5 / 5, 1, 1)
  end
  local
  function
    createBoxLines() local lines = {}
    for
    i = 1, 4
    do
      local line = Drawing.new('Line') line.Visible = false line.Thickness = 2 line.Color = Color3.fromRGB(255, 255, 255) lines[i] = line
    end
    return lines
  end
  local
  function
    updateBoxLines(lines, corners, color)
    if
    not lines or #corners < 4
    then
      return
    end
    local topLeft, topRight, bottomLeft, bottomRight = unpack(corners) lines[1].From = topLeft lines[1].To = topRight lines[2].From = topLeft lines[2].To = bottomLeft lines[3].From = topRight lines[3].To = bottomRight lines[4].From = bottomLeft lines[4].To = bottomRight
    for
    i = 1, 4
    do
      lines[i].Color = color lines[i].Visible = true
    end
    
  end
  local
  function
    hideBoxLines(lines)
    if
    not lines
    then
      return
    end
    
    for
    i = 1, 4
    do
      lines[i].Visible = false
    end
    
  end
  local
  function
    getBoxCorners(character) local hrp = character:FindFirstChild('HumanoidRootPart') local head = character:FindFirstChild('Head')
    if
    not hrp or not head
    then
      return nil
    end
    local rootPos = hrp.Position local rootScreenPos, onScreen = Camera:WorldToViewportPoint(rootPos)
    if
    not onScreen
    then
      return nil
    end
    local distance = (Camera.CFrame.Position - rootPos).Magnitude
    if
    distance == 0
    then
      return nil
    end
    local height = 3000 / distance local width = height / 2 local topLeft = Vector2.new( rootScreenPos.X - width / 2, rootScreenPos.Y - height / 2 ) local topRight = Vector2.new( rootScreenPos.X + width / 2, rootScreenPos.Y - height / 2 ) local bottomLeft = Vector2.new( rootScreenPos.X - width / 2, rootScreenPos.Y + height / 2 ) local bottomRight = Vector2.new( rootScreenPos.X + width / 2, rootScreenPos.Y + height / 2 ) return { topLeft, topRight, bottomLeft, bottomRight }
  end
  local
  function
    createESP(player)
    if
    player == LocalPlayer
    then
      return
    end
    removeESP(player)
    if
    not player.Character
    then
      return
    end
    local head = player.Character:FindFirstChild('Head') local hrp = player.Character:FindFirstChild('HumanoidRootPart')
    if
    not head or not hrp
    then
      return
    end
    local billboard = Instance.new('BillboardGui') billboard.Name = 'ESP' billboard.AlwaysOnTop = true billboard.Size = UDim2.new(0, 200, 0, 40) billboard.StudsOffset = Vector3.new(0, 2, 0) billboard.Adornee = head billboard.Parent = head local displayNameLabel = Instance.new('TextLabel') displayNameLabel.Name = 'DisplayName' displayNameLabel.BackgroundTransparency = 1 displayNameLabel.Size = UDim2.new(1, 0, 0.5, 0) displayNameLabel.Font = Enum.Font.SourceSansBold displayNameLabel.TextScaled = true displayNameLabel.TextColor3 = Color3.fromRGB(255, 255, 255) displayNameLabel.TextStrokeTransparency = 0.5 displayNameLabel.Text = player.DisplayName displayNameLabel.Visible = ShowDisplayName displayNameLabel.Parent = billboard local usernameLabel = Instance.new('TextLabel') usernameLabel.Name = 'Username' usernameLabel.BackgroundTransparency = 1 usernameLabel.Position = UDim2.new(0, 0, 0.5, 0) usernameLabel.Size = UDim2.new(1, 0, 0.5, 0) usernameLabel.Font = Enum.Font.SourceSans usernameLabel.TextScaled = true usernameLabel.TextColor3 = Color3.fromRGB(255, 255, 255) usernameLabel.TextStrokeTransparency = 0.5 usernameLabel.Text = player.Name usernameLabel.Visible = ShowUsername usernameLabel.Parent = billboard local distanceBillboard = Instance.new('BillboardGui') distanceBillboard.Name = 'DistanceESP' distanceBillboard.AlwaysOnTop = true distanceBillboard.Size = UDim2.new(0, 200, 0, 20) distanceBillboard.StudsOffset = Vector3.new(0, -3, 0) distanceBillboard.Adornee = hrp distanceBillboard.Parent = hrp local distanceLabel = Instance.new('TextLabel') distanceLabel.Name = 'Distance' distanceLabel.BackgroundTransparency = 1 distanceLabel.Size = UDim2.new(1, 0, 1, 0) distanceLabel.Font = Enum.Font.SourceSansItalic distanceLabel.TextScaled = true distanceLabel.TextColor3 = Color3.fromRGB(255, 255, 255) distanceLabel.TextStrokeTransparency = 0.5 distanceLabel.Text = '0 studs' distanceLabel.Visible = ShowDistanceESP distanceLabel.Parent = distanceBillboard local boxLines = createBoxLines() ESPObjects[player] = { Main = billboard, Distance = distanceBillboard, BoxLines = boxLines, }
  end
  
  function
    removeESP(player)
    if
    ESPObjects[player]
    then
      
      if
      ESPObjects[player].Main
      then
        ESPObjects[player].Main:Destroy()
      end
      
      if
      ESPObjects[player].Distance
      then
        ESPObjects[player].Distance:Destroy()
      end
      
      if
      ESPObjects[player].BoxLines
      then
        hideBoxLines(ESPObjects[player].BoxLines)
      end
      ESPObjects[player] = nil
    end
    
  end
  local
  function
    updateAllESP()
    for
    _, player in ipairs(Players:GetPlayers())
    do
      removeESP(player)
      if
      ESPEnabled
      then
        createESP(player)
      end
      
    end
    
  end
  RunService.RenderStepped:Connect(
  function
    ()
    if
    not ESPEnabled
    then
      return
    end
    
    for
    player, guis in pairs(ESPObjects)
    do
      
      if
      player.Character and player.Character:FindFirstChild('HumanoidRootPart') and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
      then
        local hrp = player.Character.HumanoidRootPart local dist = math.floor( ( LocalPlayer.Character.HumanoidRootPart.Position - hrp.Position ).Magnitude )
        if
        guis.Distance and guis.Distance:FindFirstChild('Distance')
        then
          guis.Distance.Distance.Text = dist .. ' studs' guis.Distance.Distance.Visible = ShowDistanceESP
        end
        local color = RainbowESP and getRainbowColor() or Color3.fromRGB(255, 255, 255)
        if
        guis.Main
        then
          
          if
          guis.Main:FindFirstChild('DisplayName')
          then
            guis.Main.DisplayName.TextColor3 = color guis.Main.DisplayName.Visible = ShowDisplayName
          end
          
          if
          guis.Main:FindFirstChild('Username')
          then
            guis.Main.Username.TextColor3 = color guis.Main.Username.Visible = ShowUsername
          end
          
        end
        
        if
        guis.Distance and guis.Distance:FindFirstChild('Distance')
        then
          guis.Distance.Distance.TextColor3 = color
        end
        
        if
        guis.BoxLines
        then
          
          if
          ShowBoxESP
          then
            local corners = getBoxCorners(player.Character)
            if
            corners
            then
              updateBoxLines(guis.BoxLines, corners, color)
            else
              hideBoxLines(guis.BoxLines)
            end
            
          else
            hideBoxLines(guis.BoxLines)
          end
          
        end
        
      else
        
        if
        guis.BoxLines
        then
          hideBoxLines(guis.BoxLines)
        end
        
      end
      
    end
    
  end
  ) local
  function
    hookCharacterAdded(player) player.CharacterAdded:Connect(
    function
      ()
      if
      ESPEnabled
      then
        task.wait(1) createESP(player)
      end
      
    end
    )
  end
  
  for
  _, player in ipairs(Players:GetPlayers())
  do
    
    if
    player ~= LocalPlayer
    then
      hookCharacterAdded(player)
      if
      player.Character and ESPEnabled
      then
        task.wait(1) createESP(player)
      end
      
    end
    
  end
  Players.PlayerAdded:Connect(
  function
    (player) hookCharacterAdded(player)
    if
    player.Character and ESPEnabled
    then
      task.wait(1) createESP(player)
    end
    
  end
  ) Players.PlayerRemoving:Connect(removeESP) local EspGroup = Tabs.Visuals:AddLeftGroupbox('Esp') EspGroup:AddToggle('ToggleESP', { Text = 'Enable ESP', Default = false, Callback =
  function
    (Value) ESPEnabled = Value updateAllESP()
  end
  , }) EspGroup:AddToggle('DisplayNameESP', { Text = 'DisplayName', Default = false, Callback =
  function
    (Value) ShowDisplayName = Value
  end
  , }) EspGroup:AddToggle('UsernameESP', { Text = 'Username', Default = false, Callback =
  function
    (Value) ShowUsername = Value
  end
  , }) EspGroup:AddToggle('DistanceESP', { Text = 'Distance', Default = false, Callback =
  function
    (Value) ShowDistanceESP = Value
  end
  , }) EspGroup:AddToggle('BoxESP', { Text = 'Boxes', Default = false, Callback =
  function
    (Value) ShowBoxESP = Value
  end
  , }) EspGroup:AddToggle('RainbowESP', { Text = 'Rainbow ESP', Default = false, Callback =
  function
    (Value) RainbowESP = Value
  end
  , }) local Players = game:GetService('Players') local RunService = game:GetService('RunService') local UserInputService = game:GetService('UserInputService') local LocalPlayer = Players.LocalPlayer local Camera = workspace.CurrentCamera
  for
  _, obj in pairs(getgc(true))
  do
    
    if
    typeof(obj) == 'DrawingObject' and obj.Type == 'Circle'
    then
      pcall(
      function
        () obj:Remove()
      end
      )
    end
    
  end
  
  if
  getgenv().FOVCircleInstance
  then
    pcall(
    function
      () getgenv().FOVCircleInstance:Remove()
    end
    ) getgenv().FOVCircleInstance = nil
  end
  getgenv().Silent = getgenv().Silent or {} getgenv().Silent.Enabled = false getgenv().Silent.FOVRadius = 100 getgenv().Silent.FOVTransparency = 0.7 getgenv().Silent.Prediction = 0.12 getgenv().Silent.TargetPart = 'HumanoidRootPart' getgenv().Silent.RainbowFOV = false getgenv().Silent.FOVPlacement = 'Mouse' getgenv().Silent.FOVColor = Color3.fromRGB(255, 255, 255) getgenv().FOVCircleInstance = Drawing.new('Circle') local FOVCircle = getgenv().FOVCircleInstance FOVCircle.Color = getgenv().Silent.FOVColor FOVCircle.Thickness = 2 FOVCircle.NumSides = 100 FOVCircle.Filled = false FOVCircle.Visible = false local
  function
    getRainbowColor() local t = tick() % 5 return Color3.fromHSV(t / 5, 1, 1)
  end
  RunService.RenderStepped:Connect(
  function
    () local mousePos = UserInputService:GetMouseLocation() local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) FOVCircle.Position = getgenv().Silent.FOVPlacement == 'Middle' and screenCenter or mousePos FOVCircle.Radius = getgenv().Silent.FOVRadius FOVCircle.Transparency = getgenv().Silent.FOVTransparency
    if
    getgenv().Silent.Enabled
    then
      FOVCircle.Visible = true FOVCircle.Color = getgenv().Silent.RainbowFOV and getRainbowColor() or getgenv().Silent.FOVColor
    else
      FOVCircle.Visible = false
    end
    
  end
  ) local
  function
    GetClosestForSilent() local closestPlayer = nil local closestDistance = getgenv().Silent.FOVRadius
    for
    _, player in ipairs(Players:GetPlayers())
    do
      
      if
      player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(getgenv().Silent.TargetPart)
      then
        local part = player.Character[getgenv().Silent.TargetPart] local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
        if
        onScreen
        then
          local referencePoint = getgenv().Silent.FOVPlacement == 'Middle' and Vector2.new( Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2 ) or UserInputService:GetMouseLocation() local dist = ( Vector2.new(screenPos.X, screenPos.Y) - referencePoint ).Magnitude
          if
          dist < closestDistance
          then
            closestDistance = dist closestPlayer = player
          end
          
        end
        
      end
      
    end
    return closestPlayer
  end
  local mt = getrawmetatable(game) local oldIndex = mt.__index setreadonly(mt, false) mt.__index = newcclosure(
  function
    (self, key)
    if
    self == LocalPlayer:GetMouse() and key == 'Hit' and getgenv().Silent.Enabled
    then
      local target = GetClosestForSilent()
      if
      target and target.Character and target.Character:FindFirstChild(getgenv().Silent.TargetPart)
      then
        local part = target.Character[getgenv().Silent.TargetPart] return part.CFrame + (part.Velocity * getgenv().Silent.Prediction)
      end
      
    end
    return oldIndex(self, key)
  end
  ) setreadonly(mt, true) local SilentAimGroup = Tabs.Combat:AddRightGroupbox('Silent Aim') SilentAimGroup:AddToggle('silentAimToggle', { Text = 'Enable Silent Aim', Default = getgenv().Silent.Enabled, Tooltip = 'Toggle Silent Aim', Callback =
  function
    (state) getgenv().Silent.Enabled = state
  end
  , }) SilentAimGroup:AddSlider('silentFOVSlider', { Text = 'FOV Radius', Default = getgenv().Silent.FOVRadius, Min = 10, Max = 1000, Rounding = 0, Tooltip = 'Size of Silent Aim FOV circle', Callback =
  function
    (value) getgenv().Silent.FOVRadius = value
  end
  , }) SilentAimGroup:AddSlider('fovTransparencySlider', { Text = 'FOV Transparency', Default = getgenv().Silent.FOVTransparency, Min = 0, Max = 1, Rounding = 2, Tooltip = 'Circle transparency (0 = invisible, 1 = full)', Callback =
  function
    (value) getgenv().Silent.FOVTransparency = value
  end
  , }) SilentAimGroup:AddSlider('predictionSlider', { Text = 'Prediction', Default = getgenv().Silent.Prediction, Min = 0, Max = 1, Rounding = 2, Tooltip = 'How far ahead to predict velocity', Callback =
  function
    (value) getgenv().Silent.Prediction = value
  end
  , }) SilentAimGroup:AddDropdown('targetPartDropdown', { Values = { 'HumanoidRootPart', 'Head' }, Default = 1, Text = 'Target Part', Tooltip = 'Choose which body part to aim at', Callback =
  function
    (value) getgenv().Silent.TargetPart = value
  end
  , }) SilentAimGroup:AddToggle('rainbowFOVToggle', { Text = 'Rainbow FOV', Default = getgenv().Silent.RainbowFOV, Tooltip = 'Toggle rainbow color
  for
  FOV circle', Callback =
  function
    (state) getgenv().Silent.RainbowFOV = state
  end
  , }) SilentAimGroup:AddDropdown('fovPlacementDropdown', { Values = { 'Mouse', 'Middle' }, Default = getgenv().Silent.FOVPlacement == 'Middle' and 2 or 1, Text = 'FOV Placement', Tooltip = 'Place circle at your mouse or screen center', Callback =
  function
    (value) getgenv().Silent.FOVPlacement = value
  end
  , }) local SelfGroup = Tabs.Visuals:AddRightGroupbox('Self ESP') local EnableSelfESP = false local SelfChams = false local RainbowSelfESP = false local SelfHighlightObj task.spawn(
  function
    ()
    while
    true
    do
      
      if
      RainbowSelfESP and EnableSelfESP and SelfHighlightObj and SelfHighlightObj.Enabled
      then
        local hue = tick() % 5 / 5 local color = Color3.fromHSV(hue, 1, 1) SelfHighlightObj.FillColor = color SelfHighlightObj.OutlineColor = Color3.new(0, 0, 0)
      end
      task.wait(0.03)
    end
    
  end
  ) local
  function
    UpdateSelfESP()
    if
    not EnableSelfESP
    then
      
      if
      SelfHighlightObj
      then
        SelfHighlightObj:Destroy() SelfHighlightObj = nil
      end
      return
    end
    local char = game.Players.LocalPlayer.Character
    if
    not char
    then
      return
    end
    
    if
    not SelfHighlightObj
    then
      SelfHighlightObj = Instance.new('Highlight') SelfHighlightObj.FillTransparency = 0.3 SelfHighlightObj.OutlineTransparency = 0 SelfHighlightObj.Adornee = char SelfHighlightObj.Parent = char
    end
    
    if
    RainbowSelfESP or SelfChams
    then
      SelfHighlightObj.Enabled = true
      if
      RainbowSelfESP
      then
        
      else
        SelfHighlightObj.FillColor = Color3.fromRGB(255, 255, 255) SelfHighlightObj.OutlineColor = Color3.fromRGB(0, 0, 0)
      end
      
    else
      SelfHighlightObj.Enabled = false
    end
    
  end
  SelfGroup:AddToggle('EnableSelfESP', { Text = 'Enable ESP', Default = false, Callback =
  function
    (Value) EnableSelfESP = Value UpdateSelfESP()
  end
  , }) SelfGroup:AddToggle('SelfChams', { Text = 'Chams', Default = false, Callback =
  function
    (Value) SelfChams = Value UpdateSelfESP()
  end
  , }) SelfGroup:AddToggle('RainbowSelfESP', { Text = 'Rainbow ESP', Default = false, Callback =
  function
    (Value) RainbowSelfESP = Value UpdateSelfESP()
  end
  , }) local FogGroup = Tabs.Visuals:AddRightGroupbox('Fog') local FogEnabled = false local FogColor = Color3.fromRGB(255, 255, 255) local RainbowFogEnabled = false local Lighting = game:GetService('Lighting') local
  function
    UpdateFog()
    if
    FogEnabled
    then
      Lighting.FogEnd = 1000 Lighting.FogStart = 0 Lighting.FogColor = FogColor
    else
      Lighting.FogEnd = 100000 Lighting.FogStart = 0
    end
    
  end
  local hue = 0 local
  function
    UpdateRainbowFog(dt)
    if
    RainbowFogEnabled and FogEnabled
    then
      hue = (hue + dt * 0.2) % 1 FogColor = Color3.fromHSV(hue, 1, 1) Lighting.FogColor = FogColor
    end
    
  end
  FogGroup:AddToggle('ToggleFog', { Text = 'Fog', Default = false, Callback =
  function
    (value) FogEnabled = value
    if
    not FogEnabled
    then
      RainbowFogEnabled = false
    end
    UpdateFog()
  end
  , }) FogGroup:AddToggle('ToggleRainbowFog', { Text = 'Rainbow Fog', Default = false, Callback =
  function
    (value) RainbowFogEnabled = value
    if
    RainbowFogEnabled
    then
      spawn(
      function
        () local RunService = game:GetService('RunService') local lastTime = tick()
        while
        RainbowFogEnabled and FogEnabled
        do
          local now = tick() local dt = now - lastTime lastTime = now UpdateRainbowFog(dt) RunService.RenderStepped:Wait()
        end
        
        if
        not RainbowFogEnabled
        then
          FogColor = Color3.new(1, 1, 1) UpdateFog()
        end
        
      end
      )
    else
      FogColor = Color3.new(1, 1, 1) UpdateFog()
    end
    
  end
  , }) local fogLabel = FogGroup:AddLabel('Fog Color') local fogColorPicker = fogLabel:AddColorPicker('fogColorPicker', { Default = FogColor, Title = 'Choose Color', Transparency = 0, Callback =
  function
    (color) FogColor = color
    if
    FogEnabled and not RainbowFogEnabled
    then
      UpdateFog()
    end
    
  end
  , }) local LeftGroup = Tabs.Visuals:AddLeftGroupbox('Fov') local player = game.Players.LocalPlayer local camera = workspace.CurrentCamera local defaultFOV = 70 camera.FieldOfView = defaultFOV local currentFOV = defaultFOV local fovEnabled = false LeftGroup:AddToggle('EnableFOV', { Text = 'Enable', Default = false, Callback =
  function
    (state) fovEnabled = state
    if
    state
    then
      camera.FieldOfView = currentFOV
    else
      camera.FieldOfView = defaultFOV
    end
    
  end
  , }) LeftGroup:AddSlider('FOVSlider', { Text = 'FOV', Default = 70, Min = 70, Max = 120, Rounding = 0, Compact = false, Callback =
  function
    (value) currentFOV = value
    if
    fovEnabled
    then
      camera.FieldOfView = value
    end
    
  end
  , }) local AntiLockGroup = Tabs.Player:AddRightGroupbox('Anti-Lock') local UserInputService = game:GetService('UserInputService') local RunService = game:GetService('RunService') local LocalPlayer = game:GetService('Players').LocalPlayer desync_setback = Instance.new('Part') desync_setback.Name = 'Desync Setback' desync_setback.Parent = workspace desync_setback.Size = Vector3.new(2, 2, 1) desync_setback.CanCollide = false desync_setback.Anchored = true desync_setback.Transparency = 1 desync = { enabled = false, mode = 'Void', teleportPosition = Vector3.new(0, 0, 0), old_position = nil, voidSpamActive = false, toggleEnabled = false, }
  function
    resetCamera()
    if
    LocalPlayer.Character
    then
      local humanoid = LocalPlayer.Character:FindFirstChild('Humanoid')
      if
      humanoid
      then
        workspace.CurrentCamera.CameraSubject = humanoid
      end
      
    end
    
  end
  
  function
    toggleDesync(state) desync.enabled = state
    if
    desync.enabled
    then
      workspace.CurrentCamera.CameraSubject = desync_setback Library:Notify( "Desync Enabled '" .. desync.mode .. "' Faisal beta $", 2 )
    else
      resetCamera() Library:Notify("Desync Disabled '" .. desync.mode .. "' Beta $", 2)
    end
    
  end
  
  function
    setDesyncMode(mode) desync.mode = mode
  end
  AntiLockGroup:AddToggle('DesyncToggle', { Text = 'Anti Aim', Default = false, Callback =
  function
    (state) desync.toggleEnabled = state
    if
    not state
    then
      toggleDesync(false)
    end
    
  end
  , }):AddKeyPicker('DesyncKeybind', { Default = 'V', Text = 'Desync', Mode = 'Toggle', Callback =
  function
    (state)
    if
    not desync.toggleEnabled or UserInputService:GetFocusedTextBox()
    then
      return
    end
    toggleDesync(not desync.enabled)
  end
  , }) AntiLockGroup:AddDropdown('DesyncMethodDropdown', { Values = { 'Void Spam', 'Void' }, Default = 'Void', Multi = false, Text = 'Method', Callback =
  function
    (selected) setDesyncMode(selected)
  end
  , }) RunService.Heartbeat:Connect(
  function
    ()
    if
    desync.enabled and LocalPlayer.Character
    then
      local rootPart = LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
      if
      rootPart
      then
        desync.old_position = rootPart.CFrame
        if
        desync.mode == 'Destroy Cheaters'
        then
          desync.teleportPosition = Vector3.new( 11223344556677889900, 153435532533223623, 1632623723723732 )
        elseif
          desync.mode == 'Underground'
          then
            desync.teleportPosition = rootPart.Position - Vector3.new(0, 12, 0)
          elseif
            desync.mode == 'Void Spam'
            then
              desync.teleportPosition = math.random(1, 2) == 1 and desync.old_position.Position or Vector3.new( math.random(1000000, 5000000), math.random(1000000, 5000000), math.random(1000000, 5000000) )
            elseif
              desync.mode == 'Void'
              then
                desync.teleportPosition = Vector3.new( rootPart.Position.X + math.random(-444444, 444444), rootPart.Position.Y + math.random(-444444, 444444), rootPart.Position.Z + math.random(-444444, 444444) )
              end
              
              if
              desync.mode ~= 'Rotation'
              then
                rootPart.CFrame = CFrame.new(desync.teleportPosition) workspace.CurrentCamera.CameraSubject = desync_setback RunService.RenderStepped:Wait() desync_setback.CFrame = desync.old_position * CFrame.new(0, rootPart.Size.Y / 2 + 0.5, 0) rootPart.CFrame = desync.old_position
              end
              
            end
            
          end
          
        end
        ) local Players = game:GetService('Players') local RunService = game:GetService('RunService') local UIS = game:GetService('UserInputService') local player = Players.LocalPlayer local character = player.Character or player.CharacterAdded:Wait() local hrp = character:WaitForChild('HumanoidRootPart') local PlayerGroup = Tabs.Player:AddLeftGroupbox('Slippery Speed') local CframeGroup = Tabs.Player:AddLeftGroupbox('Cframe Speed') local FlyGroup = Tabs.Player:AddLeftGroupbox('Cframe Fly') local cframeEnabled = false local slipperyEnabled = false local SpeedValue = 100 local humanoid local originalWalkSpeed = 16 local heartbeatConnection local characterAddedConnection local cframeConnection local keysDown = {} UIS.InputBegan:Connect(
        function
          (input, gpe)
          if
          gpe
          then
            return
          end
          
          if
          input.UserInputType == Enum.UserInputType.Keyboard
          then
            keysDown[input.KeyCode] = true
          end
          
        end
        ) UIS.InputEnded:Connect(
        function
          (input)
          if
          input.UserInputType == Enum.UserInputType.Keyboard
          then
            keysDown[input.KeyCode] = nil
          end
          
        end
        ) local
        function
          setupHumanoid() local char = player.Character or player.CharacterAdded:Wait() humanoid = char:FindFirstChildOfClass('Humanoid')
          if
          humanoid
          then
            originalWalkSpeed = humanoid.WalkSpeed
          end
          
          if
          humanoid
          then
            humanoid:GetPropertyChangedSignal('WalkSpeed'):Connect(
            function
              ()
              if
              slipperyEnabled and humanoid
              then
                
                if
                humanoid.WalkSpeed ~= SpeedValue
                then
                  humanoid.WalkSpeed = SpeedValue
                end
                
              end
              
            end
            )
          end
          
        end
        local
        function
          startSlipperySpeed()
          if
          not humanoid or not humanoid.Parent
          then
            setupHumanoid()
          end
          
          if
          humanoid
          then
            humanoid.WalkSpeed = SpeedValue
          end
          
          if
          characterAddedConnection
          then
            characterAddedConnection:Disconnect()
          end
          characterAddedConnection = player.CharacterAdded:Connect(
          function
            (char) wait(1) setupHumanoid()
            if
            slipperyEnabled and humanoid
            then
              humanoid.WalkSpeed = SpeedValue
            end
            
          end
          )
          if
          heartbeatConnection
          then
            heartbeatConnection:Disconnect()
          end
          heartbeatConnection = RunService.Heartbeat:Connect(
          function
            ()
            if
            slipperyEnabled and humanoid and humanoid.Parent
            then
              
              if
              humanoid.WalkSpeed ~= SpeedValue
              then
                humanoid.WalkSpeed = SpeedValue
              end
              
            end
            
          end
          )
        end
        local
        function
          stopSlipperySpeed()
          if
          heartbeatConnection
          then
            heartbeatConnection:Disconnect() heartbeatConnection = nil
          end
          
          if
          characterAddedConnection
          then
            characterAddedConnection:Disconnect() characterAddedConnection = nil
          end
          
          if
          humanoid and humanoid.Parent
          then
            humanoid.WalkSpeed = originalWalkSpeed or 16
          end
          
        end
        local
        function
          startCFrameSpeed()
          if
          cframeConnection
          then
            cframeConnection:Disconnect()
          end
          cframeConnection = RunService.RenderStepped:Connect(
          function
            (dt)
            if
            not cframeEnabled
            then
              return
            end
            local char = player.Character
            if
            not char
            then
              return
            end
            local hrp = char:FindFirstChild('HumanoidRootPart')
            if
            not hrp
            then
              return
            end
            local camCF = workspace.CurrentCamera.CFrame local moveDir = Vector3.new()
            if
            keysDown[Enum.KeyCode.W]
            then
              moveDir += camCF.LookVector
            end
            
            if
            keysDown[Enum.KeyCode.S]
            then
              moveDir -= camCF.LookVector
            end
            
            if
            keysDown[Enum.KeyCode.A]
            then
              moveDir -= camCF.RightVector
            end
            
            if
            keysDown[Enum.KeyCode.D]
            then
              moveDir += camCF.RightVector
            end
            
            if
            moveDir.Magnitude > 0
            then
              moveDir = Vector3.new(moveDir.X, 0, moveDir.Z).Unit hrp.CFrame = hrp.CFrame + moveDir * SpeedValue * dt
            end
            
          end
          )
        end
        local
        function
          stopCFrameSpeed()
          if
          cframeConnection
          then
            cframeConnection:Disconnect() cframeConnection = nil
          end
          
        end
        local
        function
          updateSpeedState()
          if
          cframeEnabled and slipperyEnabled
          then
            cframeEnabled = false slipperyEnabled = false library:SetValue('ToggleCframe', false) library:SetValue('Toggleslippery', false) stopCFrameSpeed() stopSlipperySpeed() return
          end
          
          if
          cframeEnabled
          then
            startCFrameSpeed() stopSlipperySpeed()
          elseif
            slipperyEnabled
            then
              stopCFrameSpeed() startSlipperySpeed()
            else
              stopCFrameSpeed() stopSlipperySpeed()
            end
            
          end
          CframeGroup:AddToggle('ToggleCframe', { Text = 'Cframe Speed', Default = false, Flag = 'ToggleCframe', Callback =
          function
            (state) cframeEnabled = state updateSpeedState()
          end
          , }):AddKeyPicker('Toggle1Keycframe', { Default = 'None', Flag = 'Toggle1Keycframe', SyncToggleState = true, Mode = 'Toggle', Text = 'Togglekeybindcframe', Callback =
          function
            (state) cframeEnabled = state library:SetValue('ToggleCframe', state) updateSpeedState()
          end
          , }) PlayerGroup:AddToggle('Toggleslippery', { Text = 'Slippery Speed', Default = false, Flag = 'Toggleslippery', Callback =
          function
            (state) slipperyEnabled = state updateSpeedState()
          end
          , }):AddKeyPicker('Togglekeybindslippery', { Default = 'None', Flag = 'Togglekeybindslippery', SyncToggleState = true, Mode = 'Toggle', Text = 'Toggleslippery', Callback =
          function
            (state) slipperyEnabled = state library:SetValue('Toggleslippery', state) updateSpeedState()
          end
          , }) UIS.InputBegan:Connect(
          function
            (input, gpe)
            if
            gpe
            then
              return
            end
            
            if
            input.UserInputType == Enum.UserInputType.Keyboard
            then
              local cframeKeyName = library.Flags['Toggle1Keycframe']
              if
              cframeKeyName and input.KeyCode == Enum.KeyCode[cframeKeyName]
              then
                local newState = not library.Flags['ToggleCframe'] library:SetValue('ToggleCframe', newState)
              end
              local slipperyKeyName = library.Flags['Togglekeybindslippery']
              if
              slipperyKeyName and input.KeyCode == Enum.KeyCode[slipperyKeyName]
              then
                local newState = not library.Flags['Toggleslippery'] library:SetValue('Toggleslippery', newState)
              end
              
            end
            
          end
          ) local flightEnabled = false local flightValue = 16 local UserInputService = game:GetService('UserInputService') local RunService = game:GetService('RunService') local LocalPlayer = game.Players.LocalPlayer local hoverHeight = nil local bindsEnabled = true local
          function
            resetFlight() local char = LocalPlayer.Character
            if
            char
            then
              local humanoid = char:FindFirstChildOfClass('Humanoid')
              if
              humanoid
              then
                humanoid.PlatformStand = false
              end
              
            end
            
          end
          local
          function
            antiFlingActivate() local char = LocalPlayer.Character
            if
            char
            then
              local hrp = char:FindFirstChild('HumanoidRootPart') local humanoid = char:FindFirstChildOfClass('Humanoid')
              if
              hrp and humanoid
              then
                humanoid.PlatformStand = true hrp.Velocity = Vector3.new(0, 0, 0)
              end
              
            end
            
          end
          local
          function
            antiFlingReset() local char = LocalPlayer.Character
            if
            char
            then
              local humanoid = char:FindFirstChildOfClass('Humanoid')
              if
              humanoid
              then
                humanoid.PlatformStand = false
              end
              
            end
            
          end
          local
          function
            setFlightCFrame()
            if
            not flightEnabled
            then
              return
            end
            local char = LocalPlayer.Character
            if
            not char
            then
              return
            end
            local hrp = char:FindFirstChild('HumanoidRootPart') local humanoid = char:FindFirstChildOfClass('Humanoid')
            if
            not hrp or not humanoid
            then
              return
            end
            humanoid.PlatformStand = true local delta = RunService.Heartbeat:Wait() or 0.016 local camCF = workspace.CurrentCamera.CFrame
            if
            targetStrafeEnabled and aiming and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild(aimPartName)
            then
              local targetPart = targetPlayer.Character[aimPartName] local angle = tick() * targetStrafeSpeed local offset = Vector3.new( math.sin(angle) * targetStrafeDistance, targetStrafeHeight, math.cos(angle) * targetStrafeDistance ) local basePos = targetPart.Position local strafePos = basePos + offset local direction = (targetPart.Position - hrp.Position).Unit direction = Vector3.new(direction.X, 0, direction.Z) local desiredCFrame = CFrame.new(strafePos, strafePos + direction) hrp.CFrame = desiredCFrame hrp.Velocity = Vector3.zero hrp.RotVelocity = Vector3.zero return
            end
            local moveDir = Vector3.new()
            if
            UserInputService:IsKeyDown(Enum.KeyCode.W)
            then
              moveDir = moveDir + Vector3.new(camCF.LookVector.X, 0, camCF.LookVector.Z)
            end
            
            if
            UserInputService:IsKeyDown(Enum.KeyCode.S)
            then
              moveDir = moveDir - Vector3.new(camCF.LookVector.X, 0, camCF.LookVector.Z)
            end
            
            if
            UserInputService:IsKeyDown(Enum.KeyCode.A)
            then
              moveDir = moveDir - Vector3.new(camCF.RightVector.X, 0, camCF.RightVector.Z)
            end
            
            if
            UserInputService:IsKeyDown(Enum.KeyCode.D)
            then
              moveDir = moveDir + Vector3.new(camCF.RightVector.X, 0, camCF.RightVector.Z)
            end
            local verticalDir = 0
            if
            UserInputService:IsKeyDown(Enum.KeyCode.Space)
            then
              verticalDir = 1
            elseif
              UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)
              then
                verticalDir = -1
              end
              hoverHeight = hoverHeight or hrp.Position.Y
              if
              verticalDir ~= 0
              then
                hoverHeight = hoverHeight + verticalDir * flightValue * delta
              end
              
              if
              moveDir.Magnitude > 0
              then
                moveDir = moveDir.Unit * flightValue * delta
              else
                moveDir = Vector3.zero
              end
              local newPos = hrp.Position + Vector3.new(moveDir.X, 0, moveDir.Z) hrp.CFrame = CFrame.new(newPos.X, hoverHeight, newPos.Z) hrp.Velocity = Vector3.zero hrp.RotVelocity = Vector3.zero
            end
            RunService.Heartbeat:Connect(
            function
              ()
              if
              speedV2Enabled
              then
                setSpeedCFrame()
              end
              
              if
              flightEnabled
              then
                setFlightCFrame()
              else
                resetFlight() hoverHeight = nil
              end
              
            end
            ) FlyGroup:AddToggle('FlightCFrameToggle', { Text = 'Flight CFrame', Default = false, Tooltip = 'Toggles CFrame-based flight', Callback =
            function
              (state) flightEnabled = state Library:Notify( 'Flight CFrame - ' .. (state and 'Enabled' or 'Disabled'), 3 )
              if
              not state
              then
                antiFlingActivate() task.spawn(
                function
                  () task.wait(0.01) antiFlingReset() task.wait(2) antiFlingReset()
                end
                ) resetFlight()
              end
              
            end
            , }):AddKeyPicker('FlightCFrameToggleKey', { Default = 'None', SyncToggleState = true, Mode = 'Toggle', Text = 'Flight Key', Tooltip = 'Toggle Flight with key', Callback =
            function
              (state)
              if
              bindsEnabled
              then
                Toggles.FlightCFrameToggle:SetValue(state)
              end
              
            end
            , }) CframeGroup:AddSlider('slidercframe', { Text = 'Cframe Speed', Default = 50, Min = 16, Max = 500, Rounding = 2, Callback =
            function
              (value) SpeedValue = value
            end
            , }) PlayerGroup:AddSlider('sliderslippery', { Text = 'Slippery Speed', Default = 50, Min = 0, Max = 500, Rounding = 2, Callback =
            function
              (value) SpeedValue = value
              if
              slipperyEnabled and humanoid
              then
                humanoid.WalkSpeed = value
              end
              
            end
            , }) FlyGroup:AddSlider('FlightAmountSlider', { Text = 'Flight Amount', Min = 1, Max = 1000, Default = 16, Rounding = 0, Callback =
            function
              (value) flightValue = value
            end
            , }) UIS.InputBegan:Connect(
            function
              (input, gpe)
              if
              gpe
              then
                return
              end
              
              if
              input.UserInputType == Enum.UserInputType.Keyboard
              then
                local cframeKey = library.Flags['Toggle1Keycframe']
                if
                cframeKey and input.KeyCode == Enum.KeyCode[cframeKey]
                then
                  cframeEnabled = not cframeEnabled library:SetValue('ToggleCframe', cframeEnabled) updateSpeedState()
                end
                local slipperyKey = library.Flags['Togglekeybindslippery']
                if
                slipperyKey and input.KeyCode == Enum.KeyCode[slipperyKey]
                then
                  slipperyEnabled = not slipperyEnabled library:SetValue('Toggleslippery', slipperyEnabled) updateSpeedState()
                end
                
              end
              
            end
            ) local AutoRedeemGroup = Tabs.Player:AddRightGroupbox('Auto Redeem Codes') AutoRedeemGroup:AddToggle('RedeemCodes', { Text = 'Auto Redeem Codes', Default = false, Tooltip = 'Automatically redeem codes when enabled', Callback =
            function
              (Value)
              if
              Value
              then
                print('Auto redeem codes enabled') startAutoRedeemCodes()
              else
                print('Auto redeem codes disabled') stopAutoRedeemCodes()
              end
              
            end
            , }) local codes = { 'HALLOWEEN25 ', 'faisal', 'faisal', 'faisal', 'faisal', 'faisal', 'ADMINABUSE ', 'faisal', 'faisal', 'faisal', } local mainEvent = game:GetService('ReplicatedStorage') :WaitForChild('MainEvent') or nil
            function
              startAutoRedeemCodes()
              for
              _, code in pairs(codes)
              do
                mainEvent:FireServer('EnterPromoCode', code) Library:Notify( 'Trying code: ' .. code .. ' Faisal beta | Private', 5 ) task.wait(4.2)
              end
              
            end
            local AutoReloadGroup = Tabs.Player:AddRightGroupbox('Auto Reload Guns') AutoReloadGroup:AddToggle('Guns', { Text = 'Auto Reload Guns', Default = false, Tooltip = 'Automatically reload guns when enabled', Callback =
            function
              (Value)
              if
              Value
              then
                print('Auto reload enabled') startAutoReload()
              else
                print('Auto reload disabled') stopAutoReload()
              end
              
            end
            , }) local autoReloadEnabled = false local reloadMethod = 'Normal'
            function
              startAutoReload() autoReloadEnabled = true task.spawn(
              function
                ()
                while
                autoReloadEnabled
                do
                  local tool = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChildWhichIsA( 'Tool' ) local ammo = tool and tool:FindFirstChild('Ammo')
                  if
                  ammo and ammo.Value <= (reloadMethod == 'Rifle' and 1 or 0)
                  then
                    game:GetService('ReplicatedStorage').MainEvent :FireServer('Reload', tool) print('Reloading...') task.wait(0.0)
                  end
                  task.wait(0.0)
                end
                
              end
              )
            end
            
            function
              stopAutoReload() autoReloadEnabled = false
            end
            local RandomGroup = Tabs.Player:AddRightGroupbox('Random Things') local player = game.Players.LocalPlayer local superJumpForce = 50 local superJumpEnabled = false local characterConnection local humanoidConnection local
            function
              applySuperJump(humanoid)
              if
              humanoid
              then
                humanoid.UseJumpPower = true humanoid.JumpPower = superJumpForce humanoid.Jump = true print('[SuperJump] Applied JumpPower:', superJumpForce)
              end
              
            end
            local
            function
              onCharacterAdded(char) local humanoid = char:WaitForChild('Humanoid', 5)
              if
              humanoid
              then
                applySuperJump(humanoid)
                if
                humanoidConnection
                then
                  humanoidConnection:Disconnect() humanoidConnection = nil
                end
                humanoidConnection = char.ChildAdded:Connect(
                function
                  (child)
                  if
                  child:IsA('Humanoid')
                  then
                    print('[SuperJump] Humanoid replaced, reapplying jump') applySuperJump(child)
                  end
                  
                end
                )
              end
              
            end
            local
            function
              toggleSuperJump(enabled) superJumpEnabled = enabled local char = player.Character
              if
              enabled
              then
                
                if
                char
                then
                  local humanoid = char:FindFirstChildOfClass('Humanoid')
                  if
                  humanoid
                  then
                    applySuperJump(humanoid)
                  end
                  
                end
                
                if
                not characterConnection
                then
                  characterConnection = player.CharacterAdded:Connect(onCharacterAdded)
                end
                
              else
                
                if
                char
                then
                  local humanoid = char:FindFirstChildOfClass('Humanoid')
                  if
                  humanoid
                  then
                    humanoid.UseJumpPower = true humanoid.JumpPower = 50
                  end
                  
                end
                
                if
                characterConnection
                then
                  characterConnection:Disconnect() characterConnection = nil
                end
                
                if
                humanoidConnection
                then
                  humanoidConnection:Disconnect() humanoidConnection = nil
                end
                
              end
              
            end
            RandomGroup:AddToggle('superJumpToggle', { Text = 'Super Jump', Default = false, Tooltip = 'Toggle Super Jump on/off', Callback =
            function
              (state) toggleSuperJump(state)
            end
            , }):AddKeyPicker('superJumpKeybind', { Default = 'None', SyncToggleState = true, Mode = 'Toggle', Text = 'Super Jump Keybind', Tooltip = 'Toggle Super Jump with this keybind', Callback =
            function
              (state) toggleSuperJump(state) library.flags['superJumpToggle'] = state
            end
            , }) RandomGroup:AddSlider('superJumpForceSlider', { Text = 'Jump Force', Default = superJumpForce, Min = 50, Max = 150, Rounding = 2, Tooltip = 'Adjust jump force', Callback =
            function
              (value) superJumpForce = value
              if
              superJumpEnabled
              then
                local char = player.Character
                if
                char
                then
                  local humanoid = char:FindFirstChildOfClass('Humanoid')
                  if
                  humanoid
                  then
                    humanoid.UseJumpPower = true humanoid.JumpPower = superJumpForce
                  end
                  
                end
                
              end
              
            end
            , }) local RunService = game:GetService('RunService') local Players = game:GetService('Players') local LocalPlayer = Players.LocalPlayer local noclipConnection local NoclipToggle = RandomGroup:AddToggle('noclipToggle', { Text = 'Noclip', Default = false, Tooltip = 'Walk through walls', Callback =
            function
              (enabled) local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
              if
              enabled
              then
                noclipConnection = RunService.Stepped:Connect(
                function
                  ()
                  for
                  _, part in ipairs(character:GetDescendants())
                  do
                    
                    if
                    part:IsA('BasePart')
                    then
                      part.CanCollide = false
                    end
                    
                  end
                  
                end
                )
              else
                
                if
                noclipConnection
                then
                  noclipConnection:Disconnect() noclipConnection = nil
                end
                
                for
                _, part in ipairs(character:GetDescendants())
                do
                  
                  if
                  part:IsA('BasePart')
                  then
                    part.CanCollide = true
                  end
                  
                end
                
              end
              
            end
            , }) NoclipToggle:AddKeyPicker('noclipKeybind', { Default = 'None', SyncToggleState = true, Mode = 'Toggle', Text = 'Noclip Keybind', Tooltip = 'Toggle Noclip with this key', Callback =
            function
              (state) library.flags['noclipToggle'] = state
            end
            , }) local UserInputService = game:GetService('UserInputService') local Players = game:GetService('Players') local LocalPlayer = Players.LocalPlayer local infiniteJumpEnabled = false RandomGroup:AddToggle('infiniteJumpToggle', { Text = 'Infinite Jump', Default = false, Tooltip = 'Allows you to jump infinitely', Callback =
            function
              (enabled) infiniteJumpEnabled = enabled
            end
            , }) UserInputService.JumpRequest:Connect(
            function
              ()
              if
              infiniteJumpEnabled
              then
                local character = LocalPlayer.Character
                if
                character
                then
                  local humanoid = character:FindFirstChildOfClass('Humanoid')
                  if
                  humanoid
                  then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                  end
                  
                end
                
              end
              
            end
            ) local originalHeight = workspace.FallenPartsDestroyHeight RandomGroup:AddToggle('AntiVoidToggle', { Text = 'Anti Void', Default = false, Callback =
            function
              (state)
              if
              state
              then
                originalHeight = workspace.FallenPartsDestroyHeight workspace.FallenPartsDestroyHeight = -math.huge
              else
                workspace.FallenPartsDestroyHeight = originalHeight
              end
              
            end
            , }) local antiStompActive = false local
            function
              startAntiStomp() local RunService = game:GetService('RunService') local
              function
                checkAndKill() local chr = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait() local hum = chr:WaitForChild('Humanoid', 5) local bodyEffects = chr:WaitForChild('BodyEffects', 5)
                if
                not bodyEffects or not hum
                then
                  warn('BodyEffects or Humanoid not found in the character!') return
                end
                local koValue = bodyEffects:WaitForChild('K.O', 5)
                if
                not koValue
                then
                  warn('K.O value not found!') return
                end
                local connection connection = RunService.Heartbeat:Connect(
                function
                  ()
                  if
                  not antiStompActive
                  then
                    connection:Disconnect() return
                  end
                  
                  if
                  koValue.Value == true and hum.Health > 0
                  then
                    hum.Health = 0
                  end
                  
                end
                )
              end
              checkAndKill() LocalPlayer.CharacterAdded:Connect(
              function
                ()
                if
                antiStompActive
                then
                  checkAndKill()
                end
                
              end
              )
            end
            RandomGroup:AddToggle('AntiStomp', { Text = 'Anti Stomp', Default = false, Callback =
            function
              (state) antiStompActive = state
              if
              state
              then
                startAntiStomp()
              end
              
            end
            , }) RandomGroup:AddToggle('ChatSpyToggle', { Text = 'Chat Spy', Default = false, Callback =
            function
              (state) local TextChatService = game:GetService('TextChatService') local StarterGui = game:GetService('StarterGui')
              if
              state
              then
                
                if
                TextChatService:FindFirstChild('ChatWindowConfiguration')
                then
                  TextChatService.ChatWindowConfiguration.Enabled = true
                end
                
                if
                TextChatService:FindFirstChild('ChatInputBarConfiguration')
                then
                  TextChatService.ChatInputBarConfiguration.Enabled = true
                end
                StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
              else
                
                if
                TextChatService:FindFirstChild('ChatWindowConfiguration')
                then
                  TextChatService.ChatWindowConfiguration.Enabled = false
                end
                
                if
                TextChatService:FindFirstChild('ChatInputBarConfiguration')
                then
                  TextChatService.ChatInputBarConfiguration.Enabled = false
                end
                StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, false)
              end
              Library:Notify( 'Chat Spy - ' .. (state and 'Enabled' or 'Disabled'), 3 )
            end
            , }) getgenv().autoArmorEnabled = false getgenv().armorThreshold = 100 local dataFolder = player:WaitForChild('DataFolder') local armorInfo = dataFolder :WaitForChild('Information') :FindFirstChild('ArmorSave') or nil local armorShop = workspace.Ignored.Shop['[High-Medium Armor] - $2513'] local armorClickDetector = armorShop.ClickDetector local
            function
              canBuyArmor() local character = player.Character
              if
              not character
              then
                return false
              end
              local humanoid = character:FindFirstChild('Humanoid')
              if
              humanoid and humanoid.Health <= 1
              then
                return false
              end
              local bodyEffects = character:FindFirstChild('BodyEffects') local isKO = bodyEffects and bodyEffects:FindFirstChild('K.O') and bodyEffects['K.O'].Value
              if
              isKO
              then
                return false
              end
              return true
            end
            local
            function
              teleportAndBuy(shop, clickDetector) local character = player.Character
              if
              not character or not character.PrimaryPart
              then
                return
              end
              local originalPosition = character.PrimaryPart.CFrame task.wait(0.1) character:SetPrimaryPartCFrame(shop.Head.CFrame * CFrame.new(0, 3.1, 0)) task.wait(0.2) fireclickdetector(clickDetector) task.wait(0.1) character:SetPrimaryPartCFrame(originalPosition) task.wait(0.1)
            end
            local
            function
              buyArmor()
              if
              armorInfo and getgenv().autoArmorEnabled and tonumber(armorInfo.Value) < getgenv().armorThreshold and canBuyArmor()
              then
                local wasDesyncEnabled = desync.enabled
                if
                wasDesyncEnabled
                then
                  toggleDesync(false)
                end
                teleportAndBuy(armorShop, armorClickDetector)
                if
                wasDesyncEnabled
                then
                  toggleDesync(true)
                end
                
              end
              
            end
            local
            function
              checkArmor()
              while
              task.wait(0.1)
              do
                
                if
                armorInfo
                then
                  buyArmor()
                end
                
              end
              
            end
            player.CharacterAdded:Connect(
            function
              () task.wait(1.4) checkArmor()
            end
            ) task.spawn(checkArmor) RandomGroup:AddToggle('AutoArmorToggle', { Text = 'Auto Armor', Default = false, Callback =
            function
              (state) getgenv().autoArmorEnabled = state
            end
            , }) local UserInputService = game:GetService('UserInputService') local RapidGroup = Tabs.Combat:AddRightGroupbox('Rapid Fire') getgenv().config = { enable = false, delay = 0.1, } getgenv().is_firing = false local utility = {} utility.get_gun =
            function
              () local char = game.Players.LocalPlayer.Character
              if
              not char
              then
                return nil
              end
              
              for
              _, tool in next, char:GetChildren()
              do
                
                if
                tool:IsA('Tool') and tool:FindFirstChild('Ammo')
                then
                  return tool
                end
                
              end
              return nil
            end
            utility.rapid =
            function
              (tool)
              if
              tool and tool.Parent
              then
                tool:Activate()
              end
              
            end
            RapidGroup:AddToggle('RapidFireToggle', { Text = 'Rapid Fire', Default = false, Tooltip = 'Automatically fires your gun', Callback =
            function
              (state) getgenv().config.enable = state
            end
            , }):AddKeyPicker('RapidFireToggleKey', { Default = 'None', SyncToggleState = true, Mode = 'Toggle', Text = 'Rapid Fire Keybind', Tooltip = 'Toggle Rapid Fire with key', Callback =
            function
              (state) getgenv().config.enable = state
            end
            , }) RapidGroup:AddSlider('RapidFireDelay', { Text = 'Fire Delay', Min = 0, Max = 0.5, Default = 0.1, Rounding = 2, Tooltip = 'Time between shots (seconds)', Callback =
            function
              (val) getgenv().config.delay = val
            end
            , }) UserInputService.InputBegan:Connect(
            function
              (input, gameProcessed)
              if
              gameProcessed
              then
                return
              end
              
              if
              input.UserInputType == Enum.UserInputType.MouseButton1
              then
                
                if
                not getgenv().config.enable
                then
                  return
                end
                
                if
                getgenv().is_firing
                then
                  return
                end
                local success, err = pcall(
                function
                  () local gun = utility.get_gun()
                  if
                  not gun
                  then
                    
                    if
                    library and library.SendNotification
                    then
                      library:SendNotification( 'No gun found with Ammo equipped!', 5 )
                    end
                    warn('Rapid Fire: No gun found.') return
                  end
                  getgenv().is_firing = true
                  while
                  getgenv().is_firing and getgenv().config.enable
                  do
                    utility.rapid(gun) task.wait(getgenv().config.delay)
                  end
                  
                end
                )
                if
                not success
                then
                  warn('Rapid Fire Error: ' .. tostring(err)) getgenv().is_firing = false
                end
                
              end
              
            end
            ) UserInputService.InputEnded:Connect(
            function
              (input)
              if
              input.UserInputType == Enum.UserInputType.MouseButton1
              then
                getgenv().is_firing = false
              end
              
            end
            ) local Players = game:GetService('Players') local RunService = game:GetService('RunService') local UserInputService = game:GetService('UserInputService') local LocalPlayer = Players.LocalPlayer local RapidFireEnabled = false local hyperFireEnabled = false local modifiedTools = {} local
            function
              rapidfire(tool)
              if
              not RapidFireEnabled
              then
                return
              end
              
              if
              not tool or not tool:FindFirstChild('GunScript') or modifiedTools[tool]
              then
                return
              end
              
              for
              _, v in ipairs(getconnections(tool.Activated))
              do
                local funcinfo = debug.getinfo(v.Function)
                for
                i = 1, funcinfo.nups
                do
                  local c = debug.getupvalue(v.Function, i)
                  if
                  type(c) == 'number'
                  then
                    debug.setupvalue(v.Function, i, 0.0000000000001)
                  end
                  
                end
                
              end
              modifiedTools[tool] = true
            end
            local
            function
              onCharacterAdded(character)
              for
              _, tool in ipairs(character:GetChildren())
              do
                
                if
                tool:IsA('Tool') and tool:FindFirstChild('Handle')
                then
                  rapidfire(tool)
                end
                
              end
              character.ChildAdded:Connect(
              function
                (child)
                if
                child:IsA('Tool') and child:FindFirstChild('Handle')
                then
                  rapidfire(child)
                end
                
              end
              )
            end
            
            if
            LocalPlayer.Character
            then
              onCharacterAdded(LocalPlayer.Character)
            end
            LocalPlayer.CharacterAdded:Connect(onCharacterAdded) RapidGroup:AddToggle('RapidFireToggle', { Text = 'Rapid Fire v2', Default = false, Tooltip = 'After toggling off reset pls', Callback =
            function
              (Value) RapidFireEnabled = Value modifiedTools = {}
              if
              Value and LocalPlayer.Character
              then
                onCharacterAdded(LocalPlayer.Character)
              end
              
            end
            , }) local
            function
              updateHyperFire()
              if
              not hyperFireEnabled
              then
                return
              end
              
              for
              _, obj in ipairs(game:GetDescendants())
              do
                
                if
                obj.Name == 'ToleranceCooldown' and obj:IsA('ValueBase')
                then
                  obj.Value = 0
                end
                
              end
              
            end
            game.DescendantAdded:Connect(
            function
              (obj)
              if
              obj.Name == 'ToleranceCooldown' and obj:IsA('ValueBase')
              then
                obj.Value = hyperFireEnabled and 0 or obj.Value
              end
              
            end
            ) RunService.RenderStepped:Connect(
            function
              ()
              if
              hyperFireEnabled and UserInputService:IsMouseButtonPressed( Enum.UserInputType.MouseButton1 )
              then
                local character = LocalPlayer.Character
                if
                character
                then
                  local tool = character:FindFirstChildOfClass('Tool')
                  if
                  tool and tool:FindFirstChild('Ammo')
                  then
                    tool:Activate()
                  end
                  
                end
                
              end
              
            end
            ) local Players = game:GetService('Players') local LocalPlayer = Players.LocalPlayer local Mouse = LocalPlayer:GetMouse() local triggerbotEnabled = false local triggerbotKeybind = false local triggerbotDelay = 0.1 local lastTriggerTime = 0 local TriggerGroup = Tabs.Combat:AddRightGroupbox('Triggerbot') local Killv1Group = Tabs.Combat:AddRightGroupbox('Killv1') Killv1Group:AddToggle('Killv1Toggle', { Text = 'Enable Killv1', Default = false, Tooltip = 'Automatically kill targets in your range', Callback =
            function
              (state) getgenv().config.enableKillv1 = state
            end
            , }):AddKeyPicker('Killv1ToggleKey', { Default = 'None', SyncToggleState = true, Mode = 'Toggle', Text = 'Killv1 Keybind', Tooltip = 'Toggle Killv1 with key', Callback =
            function
              (state) getgenv().config.enableKillv1 = state
            end
            , }) Killv1Group:AddToggle('Killv1StickyAim', { Text = 'Killv1 Sticky Aim', Default = false, Callback =
            function
              (Value) Killv1StickyAimEnabled = Value
              if
              not Value
              then
                lockedTarget = nil workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild('Humanoid') targetHighlight.Enabled = false tracer.Visible = false
              end
              
            end
            , }):AddKeyPicker('Killv1StickyAimKeybind', { Default = 'C', NoUI = false, Text = 'Killv1 Sticky Aim Key', Mode = 'Toggle', Callback =
            function
              ()
              if
              UserInputService:GetFocusedTextBox()
              then
                return
              end
              
              if
              lockedTarget
              then
                lockedTarget = nil workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild('Humanoid') targetHighlight.Enabled = false tracer.Visible = false
              else
                local camera = workspace.CurrentCamera local mouseLocation = UserInputService:GetMouseLocation() local closestTarget, closestDistance = nil, math.huge
                for
                _, otherPlayer in ipairs(Players:GetPlayers())
                do
                  
                  if
                  otherPlayer ~= LocalPlayer and otherPlayer.Character and otherPlayer.Character:FindFirstChild(targetHitPart)
                  then
                    local bodyEffects = otherPlayer.Character:FindFirstChild('BodyEffects') local isKO = bodyEffects and bodyEffects:FindFirstChild('K.O') and bodyEffects['K.O'].Value local isGrabbed = otherPlayer.Character:FindFirstChild( 'GRABBING_CONSTRAINT' )
                    if
                    (not grabCheckEnabled or not isGrabbed) and ( not friendCheckEnabled or not LocalPlayer:IsFriendsWith( otherPlayer.UserId ) )
                    then
                      local targetPart = otherPlayer.Character[targetHitPart] local screenPosition, onScreen = camera:WorldToViewportPoint(targetPart.Position)
                      if
                      onScreen
                      then
                        local distance = (Vector2.new( screenPosition.X, screenPosition.Y ) - mouseLocation).Magnitude
                        if
                        distance < closestDistance
                        then
                          closestTarget = otherPlayer closestDistance = distance
                        end
                        
                      end
                      
                    end
                    
                  end
                  
                end
                
                if
                closestTarget
                then
                  lockedTarget = closestTarget
                end
                
              end
              
            end
            , }) local
            function
              updateKillv1Targeting()
              if
              getgenv().config.enableKillv1
              then
                local closestTarget = nil local camera = workspace.CurrentCamera local mouseLocation = UserInputService:GetMouseLocation() local closestDistance = math.huge
                for
                _, otherPlayer in ipairs(Players:GetPlayers())
                do
                  
                  if
                  otherPlayer ~= LocalPlayer and otherPlayer.Character and otherPlayer.Character:FindFirstChild(targetHitPart)
                  then
                    local bodyEffects = otherPlayer.Character:FindFirstChild('BodyEffects') local isKO = bodyEffects and bodyEffects:FindFirstChild('K.O') and bodyEffects['K.O'].Value local isGrabbed = otherPlayer.Character:FindFirstChild( 'GRABBING_CONSTRAINT' )
                    if
                    (not grabCheckEnabled or not isGrabbed) and ( not friendCheckEnabled or not LocalPlayer:IsFriendsWith(otherPlayer.UserId) )
                    then
                      local targetPart = otherPlayer.Character[targetHitPart] local screenPosition, onScreen = camera:WorldToViewportPoint(targetPart.Position)
                      if
                      onScreen
                      then
                        local distance = (Vector2.new( screenPosition.X, screenPosition.Y ) - mouseLocation).Magnitude
                        if
                        distance < closestDistance
                        then
                          closestTarget = otherPlayer closestDistance = distance
                        end
                        
                      end
                      
                    end
                    
                  end
                  
                end
                
                if
                closestTarget
                then
                  lockedTarget = closestTarget
                  if
                  getgenv().config.enableKillv1
                  then
                    
                  end
                  
                end
                
              end
              
            end
            game:GetService('RunService').Heartbeat:Connect(
            function
              () updateKillv1Targeting()
            end
            ) TriggerGroup:AddToggle('TriggerbotToggle', { Text = 'Triggerbot', Default = false, Tooltip = 'Automatically fires when aiming at enemy', Callback =
            function
              (state) triggerbotEnabled = state print('[Triggerbot] Toggled:', state)
            end
            , }):AddKeyPicker('TriggerbotKeybind', { Default = 'None', SyncToggleState = true, Mode = 'Toggle', Text = 'Triggerbot Keybind', Tooltip = 'Toggle Triggerbot with keybind', Callback =
            function
              (state) triggerbotKeybind = state print('[Triggerbot] Keybind Toggled:', state)
            end
            , }) TriggerGroup:AddSlider('TriggerbotDelay', { Text = 'Triggerbot Delay', Min = 0, Max = 0.5, Default = 0.1, Rounding = 2, Tooltip = 'Delay before firing (seconds)', Callback =
            function
              (val) triggerbotDelay = val print('[Triggerbot] Delay set to:', val)
            end
            , }) local
            function
              getMouseTarget() local target = Mouse.Target
              if
              not target
              then
                return nil
              end
              local character = target:FindFirstAncestorOfClass('Model')
              if
              not character
              then
                return nil
              end
              local humanoid = character:FindFirstChildOfClass('Humanoid') local player = Players:GetPlayerFromCharacter(character)
              if
              humanoid and humanoid.Health > 0 and player and player ~= LocalPlayer
              then
                return character
              end
              return nil
            end
            task.spawn(
            function
              ()
              while
              true
              do
                task.wait()
                if
                triggerbotEnabled or triggerbotKeybind
                then
                  local target = getMouseTarget()
                  if
                  target and tick() - lastTriggerTime >= triggerbotDelay
                  then
                    
                    if
                    mouse1press and mouse1release
                    then
                      mouse1press() task.wait(0.01) mouse1release()
                    elseif
                      mouse1click
                      then
                        mouse1click()
                      end
                      lastTriggerTime = tick()
                    end
                    
                  end
                  
                end
                
              end
              ) print('all made by @faisalasyrian on discord') local HitboxGroup = Tabs.Combat:AddLeftGroupbox('Hitbox Expander') local Players = game:GetService('Players') local RunService = game:GetService('RunService') local player = Players.LocalPlayer local hitboxExpanderEnabled = false local hitboxSize = 10 local hitboxTransparency = 0.5 local hitboxConnection = nil local
              function
                logMessage(msg, isError)
                if
                isError
                then
                  warn('[Hitbox Expander Error] ' .. msg)
                else
                  print('[Hitbox Expander] ' .. msg)
                end
                
              end
              local
              function
                toggleHitboxExpander(enabled) hitboxExpanderEnabled = enabled
                if
                enabled
                then
                  logMessage('Hitbox Expander enabled', false) hitboxConnection = RunService.RenderStepped:Connect(
                  function
                    ()
                    if
                    not hitboxExpanderEnabled
                    then
                      return
                    end
                    
                    for
                    _, plr in pairs(Players:GetPlayers())
                    do
                      
                      if
                      plr ~= player and plr.Character
                      then
                        local hrp = plr.Character:FindFirstChild('HumanoidRootPart')
                        if
                        hrp
                        then
                          hrp.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize) hrp.Transparency = hitboxTransparency
                        end
                        
                      end
                      
                    end
                    
                  end
                  )
                else
                  
                  if
                  hitboxConnection
                  then
                    hitboxConnection:Disconnect() hitboxConnection = nil logMessage('Hitbox Expander disabled', false)
                  end
                  
                  for
                  _, plr in pairs(Players:GetPlayers())
                  do
                    
                    if
                    plr ~= player and plr.Character
                    then
                      local hrp = plr.Character:FindFirstChild('HumanoidRootPart')
                      if
                      hrp
                      then
                        hrp.Size = Vector3.new(2, 2, 1) hrp.Transparency = 0
                      end
                      
                    end
                    
                  end
                  
                end
                
              end
              HitboxGroup:AddToggle('HitboxToggle', { Text = 'Hitbox Expander', Default = false, Tooltip = 'Expand enemy hitboxes
              for
              easier targeting', Callback =
              function
                (state) toggleHitboxExpander(state)
              end
              , }):AddKeyPicker('HitboxKeybind', { Default = 'None', Mode = 'Toggle', SyncToggleState = true, Text = 'Hitbox Keybind', Tooltip = 'Toggle hitbox expander with keybind', Callback =
              function
                (state) toggleHitboxExpander(state)
              end
              , }) HitboxGroup:AddSlider('HitboxSizeSlider', { Text = 'Hitbox Size', Min = 0, Max = 100, Default = 100, Rounding = 0, Suffix = ' studs', Callback =
              function
                (val) hitboxSize = val logMessage('Size set to ' .. val, false)
              end
              , }) HitboxGroup:AddSlider('HitboxTransparencySlider', { Text = 'Hitbox Transparency', Min = 0, Max = 1, Default = 0.5, Rounding = 2, Callback =
              function
                (val) hitboxTransparency = val logMessage('Transparency set to ' .. val, false)
              end
              , }) task.defer(
              function
                () library.flags['HitboxToggle'] = false toggleHitboxExpander(false)
              end
              ) RandomGroup:AddButton('Guns Uphill',
              function
                () local player = game.Players.LocalPlayer
                if
                player and player.Character and player.Character:FindFirstChild('HumanoidRootPart')
                then
                  player.Character.HumanoidRootPart.CFrame = CFrame.new(478, 48, -621)
                end
                
              end
              ) RandomGroup:AddButton('Food Uphill',
              function
                () local player = game.Players.LocalPlayer
                if
                player and player.Character and player.Character:FindFirstChild('HumanoidRootPart')
                then
                  player.Character.HumanoidRootPart.CFrame = CFrame.new(304, 49, -623)
                end
                
              end
              ) RandomGroup:AddButton('Military',
              function
                () local player = game.Players.LocalPlayer
                if
                player and player.Character and player.Character:FindFirstChild('HumanoidRootPart')
                then
                  player.Character.HumanoidRootPart.CFrame = CFrame.new(35, 25, -870)
                end
                
              end
              ) RandomGroup:AddButton('Food Downhill',
              function
                () local player = game.Players.LocalPlayer
                if
                player and player.Character and player.Character:FindFirstChild('HumanoidRootPart')
                then
                  player.Character.HumanoidRootPart.CFrame = CFrame.new(-279, 22, -805)
                end
                
              end
              ) RandomGroup:AddButton('Gym',
              function
                () local player = game.Players.LocalPlayer
                if
                player and player.Character and player.Character:FindFirstChild('HumanoidRootPart')
                then
                  player.Character.HumanoidRootPart.CFrame = CFrame.new(-78, 22, -631)
                end
                
              end
              ) RandomGroup:AddButton('Rifle',
              function
                () local player = game.Players.LocalPlayer
                if
                player and player.Character and player.Character:FindFirstChild('HumanoidRootPart')
                then
                  player.Character.HumanoidRootPart.CFrame = CFrame.new(-260, 52, -218)
                end
                
              end
              ) RandomGroup:AddButton('Food Bank',
              function
                () local player = game.Players.LocalPlayer
                if
                player and player.Character and player.Character:FindFirstChild('HumanoidRootPart')
                then
                  player.Character.HumanoidRootPart.CFrame = CFrame.new(-325, 25, -294)
                end
                
              end
              ) RandomGroup:AddButton('Guns Downhill',
              function
                () local player = game.Players.LocalPlayer
                if
                player and player.Character and player.Character:FindFirstChild('HumanoidRootPart')
                then
                  player.Character.HumanoidRootPart.CFrame = CFrame.new(-582, 8, -737)
                end
                
              end
              ) RandomGroup:AddButton('Medium Armor',
              function
                () local player = game.Players.LocalPlayer
                if
                player and player.Character and player.Character:FindFirstChild('HumanoidRootPart')
                then
                  player.Character.HumanoidRootPart.CFrame = CFrame.new(37, 26, -827)
                end
                
              end
              ) RandomGroup:AddButton('High Medium Armor',
              function
                () local player = game.Players.LocalPlayer
                if
                player and player.Character and player.Character:FindFirstChild('HumanoidRootPart')
                then
                  player.Character.HumanoidRootPart.CFrame = CFrame.new(-933, -26, 568)
                end
                
              end
              ) local KillAuraGroup = Tabs.Combat:AddLeftGroupbox('Kill Aura') local Players = game:GetService('Players') local ReplicatedStorage = game:GetService('ReplicatedStorage') local LocalPlayer = Players.LocalPlayer local MainEvent = ReplicatedStorage:FindFirstChild('MainEvent') getgenv().enabled = false getgenv().active = true getgenv().range = 100 getgenv().whitelist = {} getgenv().lastHealth = {} getgenv().visualizeEnabled = false getgenv().silentEnabled = false local tracer = Instance.new('Part') tracer.Anchored = true tracer.CanCollide = false tracer.Material = Enum.Material.Neon tracer.Color = Color3.fromRGB(255, 0, 0) tracer.Transparency = 1 tracer.Size = Vector3.new(0.2, 0.2, 0.2) tracer.Parent = workspace getgenv().tracer = tracer task.spawn(
              function
                ()
                while
                true
                do
                  task.wait() local char = LocalPlayer.Character local hrp = char and char:FindFirstChild('HumanoidRootPart') local tool = char and char:FindFirstChildOfClass('Tool') local handle = tool and tool:FindFirstChild('Handle')
                  if
                  getgenv().enabled and getgenv().active and hrp and handle
                  then
                    local body = workspace:FindFirstChild('Players') and workspace.Players:FindFirstChild(LocalPlayer.Name) local effects = body and body:FindFirstChild('BodyEffects') local ko = effects and effects:FindFirstChild('K.O')
                    if
                    ko and ko.Value
                    then
                      continue
                    end
                    local closest = math.huge local target = nil
                    for
                    _, player in pairs(Players:GetPlayers())
                    do
                      
                      if
                      player ~= LocalPlayer and not getgenv().whitelist[player.Name]
                      then
                        local targetChar = player.Character local targetHRP = targetChar and targetChar:FindFirstChild('HumanoidRootPart') local head = targetChar and targetChar:FindFirstChild('Head') local targetBody = workspace.Players:FindFirstChild(player.Name) local targetEffects = targetBody and targetBody:FindFirstChild('BodyEffects') local targetKO = targetEffects and targetEffects:FindFirstChild('K.O') local humanoid = targetChar and targetChar:FindFirstChildOfClass('Humanoid')
                        if
                        targetHRP and head and humanoid and humanoid.Health > 0 and (not targetKO or targetKO.Value == false)
                        then
                          local dist = (hrp.Position - head.Position).Magnitude
                          if
                          dist < closest and dist <= getgenv().range
                          then
                            closest = dist target = player
                          end
                          
                        end
                        
                      end
                      
                    end
                    
                    if
                    target and target.Character and target.Character:FindFirstChild('Head')
                    then
                      local head = target.Character.Head
                      if
                      getgenv().visualizeEnabled
                      then
                        tracer.Transparency = 0 tracer.Size = Vector3.new( 0.2, 0.2, (hrp.Position - head.Position).Magnitude ) tracer.CFrame = CFrame.lookAt( hrp.Position, head.Position ) * CFrame.new( 0, 0, -tracer.Size.Z / 2 )
                      else
                        tracer.Transparency = 1
                      end
                      local humanoid = target.Character:FindFirstChild('Humanoid')
                      if
                      humanoid
                      then
                        
                        if
                        not getgenv().lastHealth[target.Name]
                        then
                          getgenv().lastHealth[target.Name] = humanoid.Health
                        end
                        
                        if
                        humanoid.Health < getgenv().lastHealth[target.Name]
                        then
                          
                        end
                        getgenv().lastHealth[target.Name] = humanoid.Health
                      end
                      local shootPosition = head.Position - Vector3.new(0, 12, 0) local fromPosition = handle.CFrame.Position - Vector3.new(0, 12, 0) MainEvent:FireServer( 'ShootGun', handle, fromPosition, shootPosition, head, Vector3.new(0, 0, -1) )
                    else
                      tracer.Transparency = 1
                    end
                    
                  else
                    tracer.Transparency = 1
                  end
                  
                end
                
              end
              ) KillAuraGroup:AddToggle('killAuraToggle', { Text = 'Enable Kill Aura', Default = false, Tooltip = 'Toggle Kill Aura On/Off', Callback =
              function
                (state) getgenv().enabled = state
              end
              , }) local LeftGroupBox = Tabs.Player:AddLeftGroupbox('Animation') local KeepOnDeath = false local AnimationOptions = { ['Idle1'] = 'http://www.roblox.com/asset/?id=180435571', ['Idle2'] = 'http://www.roblox.com/asset/?id=180435792', ['Walk'] = 'http://www.roblox.com/asset/?id=180426354', ['Run'] = 'http://www.roblox.com/asset/?id=180426354', ['Jump'] = 'http://www.roblox.com/asset/?id=125750702', ['Climb'] = 'http://www.roblox.com/asset/?id=180436334', ['Fall'] = 'http://www.roblox.com/asset/?id=180436148', } local AnimationSets = { ['Default'] = { idle1 = 'http://www.roblox.com/asset/?id=180435571', idle2 = 'http://www.roblox.com/asset/?id=180435792', walk = 'http://www.roblox.com/asset/?id=180426354', run = 'http://www.roblox.com/asset/?id=180426354', jump = 'http://www.roblox.com/asset/?id=125750702', climb = 'http://www.roblox.com/asset/?id=180436334', fall = 'http://www.roblox.com/asset/?id=180436148', }, ['Ninja'] = { idle1 = 'http://www.roblox.com/asset/?id=656117400', idle2 = 'http://www.roblox.com/asset/?id=656118341', walk = 'http://www.roblox.com/asset/?id=656121766', run = 'http://www.roblox.com/asset/?id=656118852', jump = 'http://www.roblox.com/asset/?id=656117878', climb = 'http://www.roblox.com/asset/?id=656114359', fall = 'http://www.roblox.com/asset/?id=656115606', }, ['Superhero'] = { idle1 = 'http://www.roblox.com/asset/?id=616111295', idle2 = 'http://www.roblox.com/asset/?id=616113536', walk = 'http://www.roblox.com/asset/?id=616122287', run = 'http://www.roblox.com/asset/?id=616117076', jump = 'http://www.roblox.com/asset/?id=616115533', climb = 'http://www.roblox.com/asset/?id=616104706', fall = 'http://www.roblox.com/asset/?id=616108001', }, ['Robot'] = { idle1 = 'http://www.roblox.com/asset/?id=616088211', idle2 = 'http://www.roblox.com/asset/?id=616089559', walk = 'http://www.roblox.com/asset/?id=616095330', run = 'http://www.roblox.com/asset/?id=616091570', jump = 'http://www.roblox.com/asset/?id=616090535', climb = 'http://www.roblox.com/asset/?id=616086039', fall = 'http://www.roblox.com/asset/?id=616087089', }, ['Cartoon'] = { idle1 = 'http://www.roblox.com/asset/?id=742637544', idle2 = 'http://www.roblox.com/asset/?id=742638445', walk = 'http://www.roblox.com/asset/?id=742640026', run = 'http://www.roblox.com/asset/?id=742638842', jump = 'http://www.roblox.com/asset/?id=742637942', climb = 'http://www.roblox.com/asset/?id=742636889', fall = 'http://www.roblox.com/asset/?id=742637151', }, ['Catwalk'] = { idle1 = 'http://www.roblox.com/asset/?id=133806214992291', idle2 = 'http://www.roblox.com/asset/?id=94970088341563', walk = 'http://www.roblox.com/asset/?id=109168724482748', run = 'http://www.roblox.com/asset/?id=81024476153754', jump = 'http://www.roblox.com/asset/?id=116936326516985', climb = 'http://www.roblox.com/asset/?id=119377220967554', fall = 'http://www.roblox.com/asset/?id=92294537340807', }, ['Zombie'] = { idle1 = 'http://www.roblox.com/asset/?id=616158929', idle2 = 'http://www.roblox.com/asset/?id=616160636', walk = 'http://www.roblox.com/asset/?id=616168032', run = 'http://www.roblox.com/asset/?id=616163682', jump = 'http://www.roblox.com/asset/?id=616161997', climb = 'http://www.roblox.com/asset/?id=616156119', fall = 'http://www.roblox.com/asset/?id=616157476', }, ['Mage'] = { idle1 = 'http://www.roblox.com/asset/?id=707742142', idle2 = 'http://www.roblox.com/asset/?id=707855907', walk = 'http://www.roblox.com/asset/?id=707897309', run = 'http://www.roblox.com/asset/?id=707861613', jump = 'http://www.roblox.com/asset/?id=707853694', climb = 'http://www.roblox.com/asset/?id=707826056', fall = 'http://www.roblox.com/asset/?id=707829716', }, ['Pirate'] = { idle1 = 'http://www.roblox.com/asset/?id=750785693', idle2 = 'http://www.roblox.com/asset/?id=750782770', walk = 'http://www.roblox.com/asset/?id=750785693', run = 'http://www.roblox.com/asset/?id=750782770', jump = 'http://www.roblox.com/asset/?id=750782770', climb = 'http://www.roblox.com/asset/?id=750782770', fall = 'http://www.roblox.com/asset/?id=750782770', }, ['Knight'] = { idle1 = 'http://www.roblox.com/asset/?id=657595757', idle2 = 'http://www.roblox.com/asset/?id=657568135', walk = 'http://www.roblox.com/asset/?id=657552124', run = 'http://www.roblox.com/asset/?id=657564596', jump = 'http://www.roblox.com/asset/?id=657560148', climb = 'http://www.roblox.com/asset/?id=657556206', fall = 'http://www.roblox.com/asset/?id=657552124', }, ['Vampire'] = { idle1 = 'http://www.roblox.com/asset/?id=1083465857', idle2 = 'http://www.roblox.com/asset/?id=1083465857', walk = 'http://www.roblox.com/asset/?id=1083465857', run = 'http://www.roblox.com/asset/?id=1083465857', jump = 'http://www.roblox.com/asset/?id=1083465857', climb = 'http://www.roblox.com/asset/?id=1083465857', fall = 'http://www.roblox.com/asset/?id=1083465857', }, ['Bubbly'] = { idle1 = 'http://www.roblox.com/asset/?id=910004836', idle2 = 'http://www.roblox.com/asset/?id=910009958', walk = 'http://www.roblox.com/asset/?id=910034870', run = 'http://www.roblox.com/asset/?id=910025107', jump = 'http://www.roblox.com/asset/?id=910016857', climb = 'http://www.roblox.com/asset/?id=910009958', fall = 'http://www.roblox.com/asset/?id=910009958', }, ['Elder'] = { idle1 = 'http://www.roblox.com/asset/?id=845386501', idle2 = 'http://www.roblox.com/asset/?id=845397899', walk = 'http://www.roblox.com/asset/?id=845403856', run = 'http://www.roblox.com/asset/?id=845386501', jump = 'http://www.roblox.com/asset/?id=845386501', climb = 'http://www.roblox.com/asset/?id=845386501', fall = 'http://www.roblox.com/asset/?id=845386501', }, ['Toy'] = { idle1 = 'http://www.roblox.com/asset/?id=782841498', idle2 = 'http://www.roblox.com/asset/?id=782841498', walk = 'http://www.roblox.com/asset/?id=782841498', run = 'http://www.roblox.com/asset/?id=782841498', jump = 'http://www.roblox.com/asset/?id=782841498', climb = 'http://www.roblox.com/asset/?id=782841498', fall = 'http://www.roblox.com/asset/?id=782841498', }, } local
              function
                applyCustomAnimations(character)
                if
                not character
                then
                  return
                end
                local Animate = character:FindFirstChild('Animate')
                if
                not Animate
                then
                  return
                end
                local ClonedAnimate = Animate:Clone() ClonedAnimate.idle.Animation1.AnimationId = AnimationOptions['Idle1'] ClonedAnimate.idle.Animation2.AnimationId = AnimationOptions['Idle2'] ClonedAnimate.walk.WalkAnim.AnimationId = AnimationOptions['Walk'] ClonedAnimate.run.RunAnim.AnimationId = AnimationOptions['Run'] ClonedAnimate.jump.JumpAnim.AnimationId = AnimationOptions['Jump'] ClonedAnimate.climb.ClimbAnim.AnimationId = AnimationOptions['Climb'] ClonedAnimate.fall.FallAnim.AnimationId = AnimationOptions['Fall'] Animate:Destroy() ClonedAnimate.Parent = character
              end
              LocalPlayer.CharacterAdded:Connect(
              function
                (character)
                if
                KeepOnDeath
                then
                  task.wait(1) applyCustomAnimations(character)
                end
                
              end
              ) local animationNames = { 'Default', 'Ninja', 'Superhero', 'Robot', 'Cartoon', 'Catwalk', 'Zombie', 'Mage', 'Pirate', 'Knight', 'Vampire', 'Bubbly', 'Elder', 'Toy', } LeftGroupBox:AddDropdown('Idle1Dropdown', { Values = animationNames, Default = 0, Multi = false, Text = 'Idle1', Callback =
              function
                (Value) AnimationOptions['Idle1'] = AnimationSets[Value].idle1 applyCustomAnimations(LocalPlayer.Character)
              end
              , }) LeftGroupBox:AddDropdown('Idle2Dropdown', { Values = animationNames, Default = 0, Multi = false, Text = 'Idle2', Callback =
              function
                (Value) AnimationOptions['Idle2'] = AnimationSets[Value].idle2 applyCustomAnimations(LocalPlayer.Character)
              end
              , }) LeftGroupBox:AddDropdown('WalkDropdown', { Values = animationNames, Default = 0, Multi = false, Text = 'Walk', Callback =
              function
                (Value) AnimationOptions['Walk'] = AnimationSets[Value].walk applyCustomAnimations(LocalPlayer.Character)
              end
              , }) LeftGroupBox:AddDropdown('RunDropdown', { Values = animationNames, Default = 0, Multi = false, Text = 'Run', Callback =
              function
                (Value) AnimationOptions['Run'] = AnimationSets[Value].run applyCustomAnimations(LocalPlayer.Character)
              end
              , }) LeftGroupBox:AddDropdown('JumpDropdown', { Values = animationNames, Default = 0, Multi = false, Text = 'Jump', Callback =
              function
                (Value) AnimationOptions['Jump'] = AnimationSets[Value].jump applyCustomAnimations(LocalPlayer.Character)
              end
              , }) LeftGroupBox:AddDropdown('ClimbDropdown', { Values = animationNames, Default = 0, Multi = false, Text = 'Climb', Callback =
              function
                (Value) AnimationOptions['Climb'] = AnimationSets[Value].climb applyCustomAnimations(LocalPlayer.Character)
              end
              , }) LeftGroupBox:AddDropdown('FallDropdown', { Values = animationNames, Default = 0, Multi = false, Text = 'Fall', Callback =
              function
                (Value) AnimationOptions['Fall'] = AnimationSets[Value].fall applyCustomAnimations(LocalPlayer.Character)
              end
              , }) LeftGroupBox:AddToggle('MyToggle', { Text = 'Keep On Death', Default = false, Tooltip = 'Keeps the animation after respawning', Callback =
              function
                (Value) KeepOnDeath = Value
              end
              , }) local DancesStored = { Dances = { ['Floss'] = 10714340543, ['Yung Blud'] = 15609995579, }, } local EmotesLeftGroupbox = Tabs.Player:AddRightGroupbox('Emotes') local CurrentDanceTrack = nil local EmoteSpeed = 10 local
              function
                PlayDance(danceName) local player = game.Players.LocalPlayer
                if
                not player or not player.Character
                then
                  return
                end
                local humanoid = player.Character:FindFirstChildOfClass('Humanoid')
                if
                humanoid
                then
                  
                  if
                  CurrentDanceTrack
                  then
                    CurrentDanceTrack:Stop() CurrentDanceTrack:Destroy() CurrentDanceTrack = nil
                  end
                  local id = DancesStored.Dances[danceName]
                  if
                  not id
                  then
                    return
                  end
                  local anim = Instance.new('Animation') anim.AnimationId = 'rbxassetid://' .. tostring(id) CurrentDanceTrack = humanoid:LoadAnimation(anim) CurrentDanceTrack:Play() CurrentDanceTrack:AdjustSpeed(EmoteSpeed / 1)
                end
                
              end
              local
              function
                StopDance()
                if
                CurrentDanceTrack
                then
                  CurrentDanceTrack:Stop() CurrentDanceTrack:Destroy() CurrentDanceTrack = nil
                end
                
              end
              EmotesLeftGroupbox:AddToggle('YungBludToggle', { Text = 'Yung Blud', Default = false, Callback =
              function
                (value)
                if
                value
                then
                  PlayDance('Yung Blud')
                else
                  StopDance()
                end
                
              end
              , }):AddKeyPicker('YungBludKey', { Default = 'J', SyncToggleState = true, Mode = 'Toggle', Text = 'Yung Blud Keybind', }) EmotesLeftGroupbox:AddToggle('FlossToggle', { Text = 'Floss', Default = false, Callback =
              function
                (value)
                if
                value
                then
                  PlayDance('Floss')
                else
                  StopDance()
                end
                
              end
              , }):AddKeyPicker('FlossKey', { Default = 'K', SyncToggleState = true, Mode = 'Toggle', Text = 'Floss Keybind', }) EmotesLeftGroupbox:AddSlider('EmoteSpeedSlider', { Text = 'Emote Speed', Default = 1, Min = 1, Max = 10, Rounding = 0, Callback =
              function
                (value) EmoteSpeed = value
                if
                CurrentDanceTrack
                then
                  CurrentDanceTrack:AdjustSpeed(EmoteSpeed / 1)
                end
                
              end
              , }) local Players = game:GetService('Players') local RunService = game:GetService('RunService') local ReplicatedStorage = game:GetService('ReplicatedStorage') local VirtualInputManager = game:GetService('VirtualInputManager') local localPlayer = Players.LocalPlayer local Camera = workspace.CurrentCamera local MainEvent = ReplicatedStorage:FindFirstChild('MainEvent') local orbitHeight = 0 local orbitSpeed = 30 local orbitRadius = 12 local
              function
                shootAtTarget(tool, enemy)
                if
                enemy and enemy.Character and enemy.Character:FindFirstChild('Head') and tool and tool:FindFirstChild('Handle')
                then
                  MainEvent:FireServer( 'ShootGun', tool.Handle, tool.Handle.CFrame.Position, enemy.Character.HumanoidRootPart.Position, enemy.Character.Head, Vector3.new(0, 0, -1) )
                end
                
              end
              local AutoKillGroup = Tabs.Combat:AddLeftGroupbox('Auto Kill') AutoKillGroup:AddInput('TargetNameInput', { Default = '', Text = 'Target Name', Placeholder = 'Type part of player name or display name', Tooltip = '', Callback =
              function
                (value) orbitInput = value:lower() selectedTarget = nil
              end
              , }) AutoKillGroup:AddToggle('AutoKillToggle', { Text = 'Auto Kill', Default = false, Tooltip = '', Callback =
              function
                (state) autoKillEnabled = state selectedTarget = nil local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait() local hrp = char:FindFirstChild('HumanoidRootPart') local backpack = LocalPlayer:WaitForChild('Backpack') local gunKeywords = { 'rifle', 'flintlock', 'aug', 'lmg' } local
                function
                  getGuns() local guns = {}
                  for
                  _, tool in ipairs(backpack:GetChildren())
                  do
                    
                    if
                    tool:IsA('Tool')
                    then
                      local name = tool.Name:lower()
                      for
                      _, keyword in ipairs(gunKeywords)
                      do
                        
                        if
                        name:find(keyword)
                        then
                          table.insert(guns, tool) break
                        end
                        
                      end
                      
                    end
                    
                  end
                  return guns
                end
                local
                function
                  getShootRemote(tool)
                  for
                  _, obj in ipairs(tool:GetDescendants())
                  do
                    
                    if
                    obj:IsA('RemoteEvent') and obj.Name:lower():find('shoot')
                    then
                      return obj
                    end
                    
                  end
                  return MainEvent
                end
                local
                function
                  fireGun(tool, target) local remote = getShootRemote(tool)
                  if
                  remote
                  then
                    
                    if
                    remote == MainEvent
                    then
                      local targetPos = target and target.Character and target.Character:FindFirstChild( 'HumanoidRootPart' ) and target.Character.HumanoidRootPart.Position
                      if
                      targetPos
                      then
                        remote:FireServer('Fire', tool, targetPos)
                      end
                      
                    else
                      remote:FireServer()
                    end
                    
                  end
                  
                end
                
                if
                state
                then
                  task.spawn(
                  function
                    ()
                    while
                    autoKillEnabled
                    do
                      local guns = getGuns()
                      if
                      orbitInput ~= ''
                      then
                        
                        for
                        _, player in ipairs(Players:GetPlayers())
                        do
                          
                          if
                          player ~= LocalPlayer and player.Character and player.Character:FindFirstChild( 'HumanoidRootPart' )
                          then
                            local uname = player.Name:lower() local dname = player.DisplayName:lower()
                            if
                            uname:find(orbitInput) or dname:find(orbitInput)
                            then
                              selectedTarget = player break
                            end
                            
                          end
                          
                        end
                        
                      end
                      
                      if
                      hrp
                      then
                        local newPos = math.random(1, 2) == 1 and hrp.Position or Vector3.new( math.random(1000000, 5000000), math.random(1000000, 5000000), math.random(1000000, 5000000) ) hrp.CFrame = CFrame.new(newPos)
                      end
                      
                      for
                      _, gun in ipairs(guns)
                      do
                        gun.Parent = char fireGun(gun, selectedTarget) local ammo = gun:FindFirstChild('Ammo')
                        if
                        ammo and ammo.Value <= 0
                        then
                          local reloading = gun:FindFirstChild('Reloading')
                          if
                          not (reloading and reloading.Value)
                          then
                            MainEvent:FireServer('Reload', gun) task.wait(1)
                          end
                          
                        end
                        task.wait(0.1) gun.Parent = backpack
                      end
                      task.wait(0.05)
                    end
                    
                  end
                  )
                end
                
              end
              , }) RunService.RenderStepped:Connect(
              function
                ()
                if
                not autoKillEnabled or not selectedTarget
                then
                  return
                end
                
                if
                not Players:FindFirstChild(selectedTarget.Name)
                then
                  selectedTarget = nil
                  if
                  lastPosition
                  then
                    local char = localPlayer.Character
                    if
                    char and char:FindFirstChild('HumanoidRootPart')
                    then
                      local hrp = char.HumanoidRootPart
                      while
                      (hrp.Position - lastPosition).Magnitude > 5
                      do
                        hrp.CFrame = CFrame.new(lastPosition) task.wait()
                      end
                      lastPosition = nil
                    end
                    
                  end
                  return
                end
                local char = localPlayer.Character local targetChar = selectedTarget.Character
                if
                not char or not targetChar
                then
                  return
                end
                local hrp = char:FindFirstChild('HumanoidRootPart') local targetHrp = targetChar:FindFirstChild('HumanoidRootPart') local targetHum = targetChar:FindFirstChildOfClass('Humanoid') local bodyEffects = targetChar:FindFirstChild('BodyEffects')
                if
                not hrp or not targetHrp or not targetHum or not bodyEffects
                then
                  return
                end
                local isKO = bodyEffects:FindFirstChild('K.O') and bodyEffects['K.O'].Value local isSDeath = bodyEffects:FindFirstChild('SDeath') and bodyEffects['SDeath'].Value
                if
                targetHum.Health <= 10 and isKO and not isSDeath
                then
                  
                  if
                  not stomping
                  then
                    stomping = true task.spawn(
                    function
                      ()
                      while
                      autoKillEnabled and selectedTarget and selectedTarget.Character
                      do
                        local bodyEffectsLoop = selectedTarget.Character:FindFirstChild( 'BodyEffects' )
                        if
                        not bodyEffectsLoop
                        then
                          break
                        end
                        local isKO_loop = bodyEffectsLoop:FindFirstChild('K.O') and bodyEffectsLoop['K.O'].Value local isSDeath_loop = bodyEffectsLoop:FindFirstChild( 'SDeath' ) and bodyEffectsLoop['SDeath'].Value
                        if
                        isSDeath_loop or not isKO_loop
                        then
                          break
                        end
                        local upperTorso = targetChar:FindFirstChild( 'UpperTorso' ) or targetChar:FindFirstChild( 'Torso' )
                        if
                        not upperTorso
                        then
                          break
                        end
                        hrp.CFrame = CFrame.new( upperTorso.Position + Vector3.new(0, 3, 0) ) MainEvent:FireServer('Stomp') task.wait(0.1)
                      end
                      
                      if
                      lastPosition
                      then
                        
                        while
                        (hrp.Position - lastPosition).Magnitude > 5
                        do
                          hrp.CFrame = CFrame.new(lastPosition) task.wait()
                        end
                        lastPosition = nil
                      end
                      stomping = false
                    end
                    )
                  end
                  return
                end
                local RunService = game:GetService('RunService') local Players = game:GetService('Players') local LocalPlayer = Players.LocalPlayer local ReplicatedStorage = game:GetService('ReplicatedStorage') local MainEvent = ReplicatedStorage:WaitForChild('MainEvent') local
                function
                  AutoReload() local char = LocalPlayer.Character
                  if
                  not char
                  then
                    return
                  end
                  local tool = char:FindFirstChildOfClass('Tool')
                  if
                  not tool
                  then
                    return
                  end
                  local ammo = tool:FindFirstChild('Ammo')
                  if
                  not ammo
                  then
                    return
                  end
                  local reloading = tool:FindFirstChild('Reloading')
                  if
                  reloading and reloading.Value
                  then
                    return
                  end
                  
                  if
                  ammo.Value <= 0
                  then
                    MainEvent:FireServer('Reload', tool) task.wait(1)
                  end
                  
                end
                
                if
                targetHum.Health < 10 and not stomping
                then
                  hrp.CFrame = hrp.CFrame + Vector3.new(0, 100000, 0) AutoReload() return
                end
                
                if
                targetHum.Health <= 100 and not stomping
                then
                  local angle = tick() * orbitSpeed local offsetX = math.cos(angle) * orbitRadius local offsetZ = math.sin(angle) * orbitRadius local orbitPos = Vector3.new( targetHrp.Position.X + offsetX, targetHrp.Position.Y + orbitHeight, targetHrp.Position.Z + offsetZ ) hrp.CFrame = CFrame.new(orbitPos, targetHrp.Position) local tool = char:FindFirstChildOfClass('Tool')
                  if
                  tool
                  then
                    shootAtTarget(tool, selectedTarget)
                  end
                  
                end
                
              end
              ) AutoKillGroup:AddSlider('OrbitHeightSlider', { Text = 'Orbit Height', Default = 0, Min = -10, Max = 10, Rounding = 1, Callback =
              function
                (value) orbitHeight = value
              end
              , }) AutoKillGroup:AddSlider('OrbitSpeedSlider', { Text = 'Orbit Speed', Default = 30, Min = 0, Max = 100, Rounding = 1, Callback =
              function
                (value) orbitSpeed = value
              end
              , }) AutoKillGroup:AddSlider('OrbitRadiusSlider', { Text = 'Orbit Radius', Default = 12, Min = 0, Max = 15, Rounding = 1, Callback =
              function
                (value) orbitRadius = value
              end
              , }) print('[SCRIPT] Script executed')
            end
            print( '╔══════════════════════════════════════════════════════════════════╗' ) print( '║ BRUTAL STARTING ║' ) print( '╚══════════════════════════════════════════════════════════════════╝' )
            if
            IsBlacklisted(UserId)
            then
              print('[MAIN] User is blacklisted') ShowBanScreen() return
            end
            ShowLoader(
            function
              () CreateKeyGUI(
              function
                (isOwner)
                if
                isOwner
                then
                  print('[MAIN] Owner detected - opening panel') ShowLoader(CreateOwnerPanel)
                else
                  print('[MAIN] Regular user - loading script') ShowLoader(LoadUserScript)
                end
                
              end
              )
            end
            ) print('[MAIN] System initialized')
